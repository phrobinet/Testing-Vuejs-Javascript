---
id: mock-function-api
title: Mock Functions
---

# Les fonctions simulées

Les fonctions fictives sont également appelées "espions", car elles vous permettent d'espionner le comportement d'une fonction qui est appelée indirectement par un autre code, plutôt que de tester uniquement la sortie. Vous pouvez créer une fonction fictive avec `jest.fn()`. Si aucune implémentation n'est donnée, la fonction fantaisie retournera `undefined` lorsqu'elle sera invoquée.

## Les méthodes

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Référence

### `mockFn.getMockName()`

Renvoie la chaîne de nom fictif définie en appelant `mockFn.mockName(value)`.

### `mockFn.mock.calls`

Un tableau contenant les arguments d'appel de tous les appels qui ont été faits à cette fonction fictive. Chaque élément du tableau est un tableau d'arguments qui ont été passés pendant l'appel.

Par exemple : Une fonction fictive `f` qui a été appelée deux fois, avec les arguments `f('arg1', 'arg2')`, et ensuite avec les arguments `f('arg3', 'arg4')`, aurait un tableau `mock.calls` qui ressemble à ceci :

```js
[
  ['arg1', 'arg2'],
  ['arg3', 'arg4'],
];
```

### `mockFn.mock.results`

Un tableau contenant les résultats de tous les appels qui ont été passés à cette fonction fictive. Chaque entrée de ce tableau est un objet contenant une propriété  `type` et une propriété  `valeur`. Le `type` sera l'un des objets suivants :

- `'return'` - Indique que l'appel s'est terminé par un retour normal.
-`'throw'` - Indique que l'appel s'est terminé par le lancement d'une valeur.
-`'incomplete'` - Indique que l'appel n'est pas encore terminé. Cela se produit si vous testez depuis la fonction fictive elle-même, ou depuis une fonction qui a été appelée par la simulation.

La propriété `value` contient la valeur qui a été lancée ou retournée. La valeur est indéfinie lorsque le `type === 'incomplete'`.

Par exemple : Une fonction fictive `f` qui a été appelée trois fois, retournant `'result1'`, lançant une erreur, et retournant ensuite `'result2'`, aurait un tableau `mock.results` qui ressemble à ceci :

```js
[
  {
    type: 'return',
    value: 'result1',
  },
  {
    type: 'throw',
    value: {
      /* Error instance */
    },
  },
  {
    type: 'return',
    value: 'result2',
  },
];
```

### `mockFn.mock.instances`

Un tableau qui contient toutes les instances d'objets qui ont été instanciées à partir de cette fonction fictive en utilisant `new`.

Par exemple : Une fonction fantaisie qui a été instanciée deux fois aura le tableau suivant `mock.instances` :

```js
const mockFn = jest.fn();

const a = new mockFn();
const b = new mockFn();

mockFn.mock.instances[0] === a; // true
mockFn.mock.instances[1] === b; // true
```

### `mockFn.mockClear()`

Réinitialise toutes les informations stockées dans les tableaux [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances).

C'est souvent utile lorsque vous voulez nettoyer les données d'utilisation d'un faux entre deux affirmations.

Attention, `mockClear` remplacera `mockFn.mock`, et pas seulement [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances). Vous devez donc éviter d'assigner `mockFn.mock` à d'autres variables, temporaires ou non, pour vous assurer que vous n'accédez pas à des données périmées.

L'option de configuration [`clearMocks`](configuration.html#clearmocks-boolean) est disponible pour effacer automatiquement les mocks entre les tests.

### `mockFn.mockReset()`

Fait tout ce que fait [`mockFn.mockClear()`](#mockfnmockclear), et supprime également toute valeur de retour ou implémentation simulée.

C'est utile lorsque vous souhaitez réinitialiser complètement un _mock_ à son état initial. (Notez que la réinitialisation d'un _espion_ résultera en une fonction sans valeur de retour).

Attention, `mockReset` remplacera `mockFn.mock`, pas seulement [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances). Vous devez donc éviter d'assigner `mockFn.mock` à d'autres variables, temporaires ou non, pour vous assurer que vous n'accédez pas à des données périmées.

### `mockFn.mockRestore()`

Fait tout ce que fait [`mockFn.mockReset()`](#mockfnmockreset), et restaure également l'implémentation originale (non simulée).

Ceci est utile lorsque vous souhaitez simuler des fonctions dans certains cas de test et restaurer l'implémentation originale dans d'autres.

Attention, `mockFn.mockRestore` ne fonctionne que lorsque la mock a été créée avec `jest.spyOn`. Vous devez donc vous occuper vous-même de la restauration lorsque vous assignez manuellement `jest.fn()`.

L'option de configuration [`restoreMocks`](configuration.html#restoremocks-boolean) est disponible pour restaurer automatiquement les mocks entre les tests.

### `mockFn.mockImplementation(fn)`

Accepte une fonction qui devrait être utilisée comme la mise en œuvre de la simulation. La simulation elle-même enregistrera tous les appels qui entrent et les instances qui viennent d'elle-même - la seule différence est que l'implémentation sera également exécutée lorsque la simulation sera appelée.

_Note : `jest.fn(implementation)` est un raccourci pour `jest.fn().mockImplementation(implementation)`._

For example:

```js
const mockFn = jest.fn().mockImplementation(scalar => 42 + scalar);
// or: jest.fn(scalar => 42 + scalar);

const a = mockFn(0);
const b = mockFn(1);

a === 42; // true
b === 43; // true

mockFn.mock.calls[0][0] === 0; // true
mockFn.mock.calls[1][0] === 1; // true
```

`mockImplementation` peut également être utilisé pour simuler des constructeurs de classe :

```js
// SomeClass.js
module.exports = class SomeClass {
  m(a, b) {}
};

// OtherModule.test.js
jest.mock('./SomeClass'); // cela se produit automatiquement avec l'automatisation
const SomeClass = require('./SomeClass');
const mMock = jest.fn();
SomeClass.mockImplementation(() => {
  return {
    m: mMock,
  };
});

const some = new SomeClass();
some.m('a', 'b');
console.log('Calls to m: ', mMock.mock.calls);
```

### `mockFn.mockImplementationOnce(fn)`

Accepte une fonction qui sera utilisée comme une implémentation de la fonction simulée pour un appel à la fonction simulée. Peut-être enchaîné de manière à ce que plusieurs appels de fonction produisent des résultats différents.

```js
const myMockFn = jest
  .fn()
  .mockImplementationOnce(cb => cb(null, true))
  .mockImplementationOnce(cb => cb(null, false));

myMockFn((err, val) => console.log(val)); // Vrai

myMockFn((err, val) => console.log(val)); // FAux
```

Lorsque la fonction simulée est à court d'implémentations définies avec mockImplementationOnce, elle exécutera l'implémentation par défaut définie avec `jest.fn(() => defaultValue)` ou `.mockImplementation(() => defaultValue)` si elles ont été appelées :

```js
const myMockFn = jest
  .fn(() => 'default')
  .mockImplementationOnce(() => 'first call')
  .mockImplementationOnce(() => 'second call');

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### `mockFn.mockName(value)`

Accepte une chaîne à utiliser dans la sortie des résultats de test à la place de "jest.fn()" pour indiquer quelle fonction fictive est référencée.

Par exemple :

```js
const mockFn = jest.fn().mockName('mockedFunction');
// mockFn();
expect(mockFn).toHaveBeenCalled();
```

entraînera cette erreur :

```
expect(mockedFunction).toHaveBeenCalled()

Expected mock function "mockedFunction" to have been called, but it was not called.
```

### `mockFn.mockReturnThis()`

Fonction de sucre syntactique pour :

```js
jest.fn(function () {
  return this;
});
```

### `mockFn.mockReturnValue(value)`

Accepte une valeur qui sera retournée chaque fois que la fonction fictive est appelée.

```js
const mock = jest.fn();
mock.mockReturnValue(42);
mock(); // 42
mock.mockReturnValue(43);
mock(); // 43
```

### `mockFn.mockReturnValueOnce(value)`

Accepte une valeur qui sera renvoyée pour un appel à la fonction fictive. Peut-être enchaînée de sorte que les appels successifs à la fonction fictive renvoient des valeurs différentes. Lorsqu'il n'y a plus de valeurs `mockReturnValueOnce` à utiliser, les appels retourneront une valeur spécifiée par `mockReturnValue`.

```js
const myMockFn = jest
  .fn()
  .mockReturnValue('default')
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call');

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### `mockFn.mockResolvedValue(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementation(() => Promise.resolve(value));
```

Utile pour simuler les fonctions d'asynchronisation dans les tests d'asynchronisation :

```js
test('async test', async () => {
  const asyncMock = jest.fn().mockResolvedValue(43);

  await asyncMock(); // 43
});
```

### `mockFn.mockResolvedValueOnce(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
```

Utile pour simuler les fonctions d'asynchronisation dans les tests d'asynchronisation :

```js
test('async test', async () => {
  const asyncMock = jest
    .fn()
    .mockResolvedValue('default')
    .mockResolvedValueOnce('first call')
    .mockResolvedValueOnce('second call');

  await asyncMock(); // first call
  await asyncMock(); // second call
  await asyncMock(); // default
  await asyncMock(); // default
});
```

### `mockFn.mockRejectedValue(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementation(() => Promise.reject(value));
```

Utile pour créer des fonctions asynchrones fictives qui seront toujours rejetées :

```js
test('async test', async () => {
  const asyncMock = jest.fn().mockRejectedValue(new Error('Async error'));

  await asyncMock(); // throws "Async error"
});
```

### `mockFn.mockRejectedValueOnce(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementationOnce(() => Promise.reject(value));
```

Exemple d'utilisation :

```js
test('async test', async () => {
  const asyncMock = jest
    .fn()
    .mockResolvedValueOnce('first call')
    .mockRejectedValueOnce(new Error('Async error'));

  await asyncMock(); // first call
  await asyncMock(); // throws "Async error"
});
```
