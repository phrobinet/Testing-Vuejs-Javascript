---
id: expect
title: Expect
---

Lorsque vous passez des tests, vous devez souvent vérifier que les valeurs répondent à certaines conditions. `expect` vous donne accès à un certain nombre de "matchers" qui vous permettent de valider différentes choses.

Pour obtenir d'autres "matchers" Jest, gérés par la communauté Jest, consultez [`jest-extended`] (https://github.com/jest-community/jest-extended).

## Les méthodes

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Les références

### `expect(value)`

La fonction `expect` est utilisée chaque fois que vous voulez tester une valeur. Il est rare que vous appeliez la fonction `expect` par elle-même. Au lieu de cela, vous utiliserez `expect` avec une fonction "matcher" pour affirmer quelque chose sur la valeur.

Il est plus facile de comprendre cela avec un exemple. Disons que vous avez une méthode `bestLaCroixFlavor()` qui est censée retourner la chaîne `'grapefruit'`. Voici comment vous pourriez tester cela :


```js
test('the best flavor is grapefruit', () => {
  expect(bestLaCroixFlavor()).toBe('grapefruit');
});
```
Dans ce cas, `toBe` est une fonction d'appariement. Il existe un grand nombre de fonctions de matcher différentes, documentée ci-dessous, pour vous aider à tester différentes choses.

L'argument `expect` doit être la valeur que votre code produit, et tout argument  au matcher doit être la valeur correcte. Si vous les mélangez, vos tests fonctionneront toujours, mais les messages d'erreur des tests d'échoués seront étranges.

### `expect.extend(matchers)`

Vous pouvez utiliser `expect.extend` pour ajouter vos propres correspondants à Jest. Par exemple, disons que vous testez une bibliothèque d'utilitaires de nombres et que vous affirmez fréquemment que des nombres apparaissent dans des plages particulières d'autres nombres. Vous pourriez résumer cela dans un appariement `toBeWithinRange` :

```js
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

test('numeric ranges', () => {
  expect(100).toBeWithinRange(90, 110);
  expect(101).not.toBeWithinRange(0, 100);
  expect({apples: 6, bananas: 3}).toEqual({
    apples: expect.toBeWithinRange(1, 10),
    bananas: expect.not.toBeWithinRange(11, 20),
  });
});
```

_Note : En TypeScript, lorsque vous utilisez `@types/jest` par exemple, vous pouvez déclarer le nouveau comparateur `toBeWithinRange` comme ceci :

```ts
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeWithinRange(a: number, b: number): R;
    }
  }
}
```

#### Les Matchers Async

`expect.extend` prend également en charge les matchers asynchrones. Les matchers asynchrones renvoient une promesse, vous devrez donc attendre la valeur renvoyée. Utilisons un exemple de matcher pour illustrer leur utilisation. Nous allons implémenter un appariement appelé `toBeDivisibleByExternalValue`, où le nombre divisible sera tiré d'une source externe.

```js
expect.extend({
  async toBeDivisibleByExternalValue(received) {
    const externalValue = await getExternalValueFromRemoteSource();
    const pass = received % externalValue == 0;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be divisible by ${externalValue}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be divisible by ${externalValue}`,
        pass: false,
      };
    }
  },
});

test('is divisible by external value', async () => {
  await expect(100).toBeDivisibleByExternalValue();
  await expect(101).not.toBeDivisibleByExternalValue();
});
```

#### Les API personnalisé Matchers


Les correspondants doivent rendre un objet (ou une promesse d'objet) avec deux clés. La touche `pass` indique s'il y a eu correspondance ou non, et la touche `message` fournit une fonction sans argument qui renvoie un message d'erreur en cas d'échec. Ainsi, lorsque `pass` est faux, `message` devrait renvoyer le message d'erreur pour le cas où `expect(x).yourMatcher()` échouerait. Et quand "pass" est vrai, "message" doit renvoyer le message d'erreur pour le cas où `expect(x).not.yourMatcher()` échoue.

Les correspondants sont appelés avec l'argument passé à `expect(x)` suivi par les arguments passés à `.yourMatcher(y, z)` :

```js
expect.extend({
  yourMatcher(x, y, z) {
    return {
      pass: true,
      message: () => '',
    };
  },
});
```

Ces fonctions et propriétés d'aide peuvent être trouvées sur `this` à l'intérieur d'un Custom Matcher :

#### `this.isNot`

Un booléen pour vous faire savoir que ce "matcher" a été appelé avec le modificateur négatif `.not` vous permettant d'afficher un indice de matcher clair et correct (voir l'exemple de code).

#### `this.promise`

Une chaîne vous permettant d'afficher un indice de correspondance clair et correct :

- `'rejects'` si le matcher a été appelé avec le modificateur `.rejects` de la promesse
- `'resolves'` si le matcher a été appelé avec la promesse `.resolves` modificateur
- `''` si le matcher n'a pas été appelé avec un modificateur de promesse

#### `this.equals(a, b)`

Il s'agit d'une fonction d'égalité profonde qui retournera `true` si deux objets ont les mêmes valeurs (de manière récursive).

#### `this.expand`

Un booléen pour vous faire savoir que ce matcher a été appelé avec une option `expand`. Lorsque Jest est appelé avec l'option `--expand`, `this.expand` peut être utilisé pour déterminer si Jest doit afficher les différences et erreurs complètes.

#### `this.utils`

Il existe un certain nombre d'outils utiles exposés sur `this.utils`, qui consistent principalement en des exportations de [`jest-matcher-utils`] (https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils).

Les plus utiles sont `matcherHint`, `printExpected` et `printReceived` pour formater les messages d'erreur. Par exemple, jetez un oeil à l'implémentation de l'appariement `toBe` :


```js
const diff = require('jest-diff');
expect.extend({
  toBe(received, expected) {
    const options = {
      comment: 'Object.is equality',
      isNot: this.isNot,
      promise: this.promise,
    };

    const pass = Object.is(received, expected);

    const message = pass
      ? () =>
          this.utils.matcherHint('toBe', undefined, undefined, options) +
          '\n\n' +
          `Expected: not ${this.utils.printExpected(expected)}\n` +
          `Received: ${this.utils.printReceived(received)}`
      : () => {
          const diffString = diff(expected, received, {
            expand: this.expand,
          });
          return (
            this.utils.matcherHint('toBe', undefined, undefined, options) +
            '\n\n' +
            (diffString && diffString.includes('- Expect')
              ? `Difference:\n\n${diffString}`
              : `Expected: ${this.utils.printExpected(expected)}\n` +
                `Received: ${this.utils.printReceived(received)}`)
          );
        };

    return {actual: received, message, pass};
  },
});
```

Cela permettra d'avoir quelque chose comme ceci :

```bash
  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      "banana"
    Received:
      "apple"
```

Lorsqu'une assertion échoue, le message d'erreur doit donner autant de signal que nécessaire à l'utilisateur afin qu'il puisse résoudre son problème rapidement. Vous devez élaborer un message d'échec précis pour vous assurer que les utilisateurs de vos assertions personnalisées ont une bonne expérience de développement.

#### Personnaliser les matchers snapshot

Pour utiliser le test de l'instantané dans votre Custom Matcher, vous pouvez importer un `jest-snapshot` et l'utiliser dans votre Matcher.

Voici un snapshot qui coupe une chaîne à stocker pour une longueur donnée, `.toMatchTrimmedSnapshot(length)` :

```js
const {toMatchSnapshot} = require('jest-snapshot');

expect.extend({
  toMatchTrimmedSnapshot(received, length) {
    return toMatchSnapshot.call(
      this,
      received.substring(0, length),
      'toMatchTrimmedSnapshot',
    );
  },
});

it('stores only 10 characters', () => {
  expect('extra long string oh my gerd').toMatchTrimmedSnapshot(10);
});

/*
Stored snapshot will look like:

exports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `"extra long"`;
*/
```

Il est également possible de créer des correspondances personnalisées pour les instantanés en ligne, les instantanés seront correctement ajoutés aux correspondances personnalisées. Cependant, les instantanés en ligne essaieront toujours de s'ajouter au premier argument ou au second lorsque le premier argument est le comparateur de propriétés, il n'est donc pas possible d'accepter des arguments personnalisés dans les comparateurs personnalisés.

```js
const {toMatchInlineSnapshot} = require('jest-snapshot');

expect.extend({
  toMatchTrimmedInlineSnapshot(received) {
    return toMatchInlineSnapshot.call(this, received.substring(0, 10));
  },
});

it('stores only 10 characters', () => {
  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot();
  /*
  L'instantané sera ajouté en ligne comme
  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(
    "extra long"
  ) ;
  */
});
```

### `expect.anything()`

Le terme `expect.anything()` correspond à tout sauf `null` ou `undefined`. Vous pouvez l'utiliser dans `toEqual` ou `toBeCalledWith` au lieu d'une valeur littérale. Par exemple, si vous voulez vérifier qu'une fonction fictive est appelée avec un argument non nul :

```js
test('map calls its argument with a non-null argument', () => {
  const mock = jest.fn();
  [1].map(x => mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
```

### `expect.any(constructor)`

`expect.any(constructor)` correspond à tout ce qui a été créé avec le constructeur donné. Vous pouvez l'utiliser dans `toEqual` ou `toBeCalledWith` au lieu d'une valeur littérale. Par exemple, si vous voulez vérifier qu'une fonction fictive est appelée avec un nombre :

```js
function randocall(fn) {
  return fn(Math.floor(Math.random() * 6 + 1));
}

test('randocall calls its callback with a number', () => {
  const mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(Number));
});
```

### `expect.arrayContaining(array)`


Le fichier `expect.arrayContaining(array)` correspond à un tableau reçu qui contient tous les éléments du tableau attendu. C'est-à-dire que le tableau attendu est un **sous-ensemble** du tableau reçu. Par conséquent, il correspond à un tableau reçu qui contient des éléments qui ne sont pas **not** dans le tableau attendu.

Vous pouvez l'utiliser à la place d'une valeur littérale :

- dans `toEqual` ou `toBeCalledWith`.
- pour correspondre à une propriété dans `objectContaining` ou `toMatchObject`.

```js
describe('arrayContaining', () => {
  const expected = ['Alice', 'Bob'];
  it('matches even if received contains additional elements', () => {
    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));
  });
  it('does not match if received does not contain expected elements', () => {
    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));
  });
});
```

```js
describe('Beware of a misunderstanding! A sequence of dice rolls', () => {
  const expected = [1, 2, 3, 4, 5, 6];
  it('matches even with an unexpected number 7', () => {
    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it('does not match without an expected number 2', () => {
    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
```

### `expect.assertions(number)`

`expect.assertions(number)` verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.

For example, let's say that we have a function `doAsync` that receives two callbacks `callback1` and `callback2`, it will asynchronously call both of them in an unknown order. We can test this with:

Le paramètre `expect.assertions(number)` vérifie qu'un certain nombre d'assertions sont appelées pendant un test. Cela est souvent utile lors de tests de code asynchrone, afin de s'assurer que les assertions d'un rappel ont bien été appelées.

Par exemple, disons que nous avons une fonction `doAsync` qui reçoit deux callbacks `callback1` et `callback2`, elle les appellera tous les deux de manière asynchrone dans un ordre inconnu. Nous pouvons tester cela avec :

```js
test('doAsync calls both callbacks', () => {
  expect.assertions(2);
  function callback1(data) {
    expect(data).toBeTruthy();
  }
  function callback2(data) {
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
```

L'appel `expect.assertions(2)` assure que les deux rappels sont effectivement appelés.

### `expect.hasAssertions()`

La fonction `expect.hasAssertions()` vérifie qu'au moins une assertion est appelée pendant un test. Ceci est souvent utile lors de tests de code asynchrone, afin de s'assurer que les assertions d'un callback ont bien été appelées.


Par exemple, disons que nous avons quelques fonctions qui traitent toutes de l'état. `prepareState` appelle un callback avec un objet d'état, `validateState` s'exécute sur cet objet d'état, et `waitOnState` renvoie une promesse qui attend que tous les callbacks `prepareState` soient terminés. Nous pouvons tester cela avec :

```js
test('prepareState prepares a valid state', () => {
  expect.hasAssertions();
  prepareState(state => {
    expect(validateState(state)).toBeTruthy();
  });
  return waitOnState();
});
```

L'appel `expect.hasAssertions()` assure que le rappel `prepareState` est effectivement appelé.

### `expect.not.arrayContaining(array)`

`Expect.not.arrayContaining(array)` correspond à un tableau reçu qui ne contient pas tous les éléments du tableau attendu. C'est-à-dire que le tableau attendu **n'est pas un sous-ensemble** du tableau reçu.

C'est l'inverse de `expect.arrayContaining`.

```js
describe('not.arrayContaining', () => {
  const expected = ['Samantha'];

  it('matches if the actual array does not contain the expected elements', () => {
    expect(['Alice', 'Bob', 'Eve']).toEqual(
      expect.not.arrayContaining(expected),
    );
  });
});
```

### `expect.not.objectContaining(object)`

`expect.not.objectContaining(object)` correspond à tout objet reçu qui ne correspond pas récursivement aux propriétés attendues. C'est-à-dire que l'objet attendu **n'est pas un sous-ensemble** de l'objet reçu. Par conséquent, il correspond à un objet reçu qui contient des propriétés qui ne sont **pas** dans l'objet attendu.

C'est l'inverse de `expect.objectContaining`.

```js
describe('not.objectContaining', () => {
  const expected = {foo: 'bar'};

  it('matches if the actual object does not contain expected key: value pairs', () => {
    expect({bar: 'baz'}).toEqual(expect.not.objectContaining(expected));
  });
});
```

### `expect.not.stringContaining(string)`

`expect.not.stringContaining(string)` `expect.not.stringContaining(string)` vérifie la valeur reçu si ce n'est pas une chaîne de caractères ou si c'est une chaîne qui ne contient pas la chaîne attendue exacte.

C'est l'inverse de `expect.stringContaining`.
```js
describe('not.stringContaining', () => {
  const expected = 'Hello world!';

  it('matches if the received value does not contain the expected substring', () => {
    expect('How are you?').toEqual(expect.not.stringContaining(expected));
  });
});
```

### `expect.not.stringMatching(string | regexp)`

`expect.not.stringMatching(string | regexp)` correspond à la valeur reçue si ce n'est pas une chaîne ou si c'est une chaîne qui ne correspond pas à la chaîne ou à l'expression régulière attendue.

C'est l'inverse de `expect.stringMatching`.

```js
describe('not.stringMatching', () => {
  const expected = /Hello world!/;

  it('matches if the received value does not match the expected regex', () => {
    expect('How are you?').toEqual(expect.not.stringMatching(expected));
  });
});
```

### `expect.objectContaining(object)`

`expect.objectContaining(object)` correspond à tout objet reçu qui correspond récursivement aux propriétés attendues. Autrement dit, l'objet attendu est un **sous-ensemble** de l'objet reçu. Par conséquent, il correspond à un objet reçu qui contient des propriétés qui **sont présentes** dans l'objet attendu.

Au lieu de valeurs de propriétés littérales dans l'objet attendu, vous pouvez utiliser des appariements, `expect.anything()`, et ainsi de suite.

Par exemple, disons que nous nous attendons à ce qu'une fonction `onPress` soit appelée avec un objet `Event`, et tout ce que nous devons vérifier est que l'événement a des propriétés `event.x` et `event.y`. Nous pouvons faire cela avec :

```js
test('onPress gets called with the right thing', () => {
  const onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      x: expect.any(Number),
      y: expect.any(Number),
    }),
  );
});
```

### `expect.stringContaining(string)`

`expect.stringContaining(string)` correspond à la valeur reçue s'il s'agit d'une chaîne qui contient la chaîne exacte attendue.

### `expect.stringMatching(string | regexp)`

Vous pouvez l'utiliser à la place d'une valeur littérale :

- dans `toEqual` ou `toBeCalledWith`.
- pour correspondre à un élément dans `arrayContaining`.
- pour correspondre à une propriété dans `objectContaining` ou `toMatchObject`.

Cet exemple montre également comment vous pouvez imbriquer plusieurs correspondants asymétriques, avec `expect.stringMatching` dans le `expect.arrayContaining`".

```js
describe('stringMatching in arrayContaining', () => {
  const expected = [
    expect.stringMatching(/^Alic/),
    expect.stringMatching(/^[BR]ob/),
  ];
  it('matches even if received contains additional elements', () => {
    expect(['Alicia', 'Roberto', 'Evelina']).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it('does not match if received does not contain expected elements', () => {
    expect(['Roberto', 'Evelina']).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
```

### `expect.addSnapshotSerializer(serializer)`

Vous pouvez appeler `expect.addSnapshotSerializer` pour ajouter un module qui formate des structures de données spécifiques à l'application.

Pour un fichier de test individuel, un module ajouté précède tous les modules de la configuration de `snapshotSerializers`, qui précèdent les sérialiseurs snapshot par défaut pour les types JavaScript intégrés et pour les éléments React. Le dernier module ajouté est le premier module testé.

```js
import serializer from 'my-serializer-module';
expect.addSnapshotSerializer(serializer);

// affecte les assertions expect(value).toMatchSnapshot() dans le fichier de test
```

Si vous ajoutez un snapshot sérialiser dans les fichiers de test individuels au lieu de l'ajouter à la configuration de `snapshotSerializers` :

- Vous rendez la dépendance explicite au lieu de l'implicite.
- Vous évitez les limites de configuration qui pourraient vous faire éjecter de [create-react-app](https://github.com/facebookincubator/create-react-app).

Voir [configuring Jest](Configuration.md#snapshotserializers-arraystring) pour plus d'informations.

### `.not`

Si vous savez comment tester quelque chose, ".not" vous permet de tester son contraire. Par exemple, ce code teste que la meilleure saveur de La Croix n'est pas la noix de coco :

```js
test('the best flavor is not coconut', () => {
  expect(bestLaCroixFlavor()).not.toBe('coconut');
});
```

### `.resolves`

Utilisez les `resolves` pour ouvrir la valeur d'une promesse tenue afin d'enchaîner tout autre partenaire. Si la promesse est rejetée, l'affirmation échoue.

Par exemple, ce code teste que la promesse est résolue et que la valeur résultante est `'lemon'` :

```js
test('resolves to lemon', () => {
  // s'assurer d'ajouter une déclaration de retour
  return expect(Promise.resolve('lemon')).resolves.toBe('lemon');
});
```

Notez que, puisque vous testez encore les promesses, le test est toujours asynchrone. Par conséquent, vous devrez [dire à Jest d'attendre](TestingAsyncCode.md#promises) en renvoyant l'affirmation non emballée.

Alternativement, vous pouvez utiliser `async/await` en combinaison avec `.resolves` :

```js
test('resolves to lemon', async () => {
  await expect(Promise.resolve('lemon')).resolves.toBe('lemon');
  await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');
});
```

### `.rejects`

Utilisez `.rejects` pour ouvrir la raison du rejects d'une promesse afin que tout autre correspondant puisse être enchaîné. Si la promesse est tenue, l'affirmation échoue.

Par exemple, ce code teste que la promesse est rejetée avec la raison `'octopus'` :

```js
test('rejects to octopus', () => {
  // s'assurer d'ajouter une déclaration de retour
  return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(
    'octopus',
  );
});
```

Notez que, puisque vous testez encore les promesses, le test est toujours asynchrone. Par conséquent, vous devrez [dire à Jest d'attendre](TestingAsyncCode.md#promises) en renvoyant l'affirmation non emballée.

Vous pouvez aussi utiliser `async/await` en combinaison avec `.rejects`.

```js
test('rejects to octopus', async () => {
  await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');
});
```

### `.toBe(value)`

Utilisez `.toBe` pour comparer des valeurs primitives ou pour vérifier l'identité référentielle des instances d'un objet. Il appelle `Object.is` pour comparer des valeurs, ce qui est encore mieux pour les tests que l'opérateur d'égalité stricte `===`.

Par exemple, ce code va valider certaines propriétés de l'objet `can` :

```js
const can = {
  name: 'pamplemousse',
  ounces: 12,
};

describe('the can', () => {
  test('has 12 ounces', () => {
    expect(can.ounces).toBe(12);
  });

  test('has a sophisticated name', () => {
    expect(can.name).toBe('pamplemousse');
  });
});
```

N'utilisez pas de ".toBe" avec des nombres à virgule flottante. Par exemple, en raison de l'arrondissement, en JavaScript, `0.2 + 0.1` n'est pas strictement égal à `0.3`. Si vous avez des nombres à virgule flottante, essayez plutôt `.toBeCloseTo`.

Bien que l'appariement `.toBe` vérifie** l'identité référentielle, il **rapporte** une comparaison approfondie des valeurs si l'assertion échoue. Si les différences entre les propriétés ne vous aident pas à comprendre pourquoi un test échoue, en particulier si le rapport est important, alors vous pouvez déplacer la comparaison dans la fonction `expect`. Par exemple, pour affirmer si des éléments sont la même instance ou non :

- réécrivez `expect(received).toBe(expected)` comme `expect(Object.is(received, expected)).toBe(true)`.
- réécrire `expect(received).not.toBe(expected)` comme `expect(Object.is(received, expected)).toBe(false)`.

### `.toHaveBeenCalled()`

Également sous l'alias : `.toBeCalled()`.

Utilisez `toHaveBeenCalled` pour vous assurer qu'une fonction fictive a été appelée.

Par exemple, disons que vous avez une fonction `drinkAll(drink, flavour)` qui prend une fonction `drink` et l'applique à toutes les boissons disponibles. Vous pouvez vérifier que `drink` est appelé pour `"lemon"`, mais pas pour `"octopus"`, parce que le goût `"octopus"` est vraiment bizarre et pourquoi quelque chose aurait un goût de poulpe ? Vous pouvez faire cela avec cette suite de tests :

```js
function drinkAll(callback, flavour) {
  if (flavour !== 'octopus') {
    callback(flavour);
  }
}

describe('drinkAll', () => {
  test('drinks something lemon-flavoured', () => {
    const drink = jest.fn();
    drinkAll(drink, 'lemon');
    expect(drink).toHaveBeenCalled();
  });

  test('does not drink something octopus-flavoured', () => {
    const drink = jest.fn();
    drinkAll(drink, 'octopus');
    expect(drink).not.toHaveBeenCalled();
  });
});
```

### `.toHaveBeenCalledTimes(number)`

Également sous l'alias : `.toBeCalledTimes(number)`

Utilisez "toHaveBeenCalledTimes" pour vous assurer qu'une fonction fictive a été appelée le nombre exact de fois.

Par exemple, disons que vous avez une fonction `drinkEach(drink, Array<flavor>)` qui prend une fonction `drink` et l'applique à un tableau de boissons passées. Vous pourriez vouloir vérifier que la fonction "drink" a été appelée le nombre exact de fois. Vous pouvez le faire avec cette suite de tests :

```js
test('drinkEach drinks each drink', () => {
  const drink = jest.fn();
  drinkEach(drink, ['lemon', 'octopus']);
  expect(drink).toHaveBeenCalledTimes(2);
});
```

### `.toHaveBeenCalledWith(arg1, arg2, ...)`

Également sous l'alias : `.toBeCalledWith()`

Utilisez `.toHaveBeenCalledWith` pour vous assurer qu'une fonction fictive a été appelée avec des arguments spécifiques.

Par exemple, disons que vous pouvez enregistrer une boisson avec une fonction `register`, et que `applyToAll(f)` devrait appliquer la fonction `f` à toutes les boissons enregistrées. Pour être sûr que cela fonctionne, vous pouvez écrire :

```js
test('registration applies correctly to orange La Croix', () => {
  const beverage = new LaCroix('orange');
  register(beverage);
  const f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
```

### `.toHaveBeenLastCalledWith(arg1, arg2, ...)`

Également sous l'alias : `.lastCalledWith(arg1, arg2, ...)`

Si vous avez une fonction fictive, vous pouvez utiliser `.toHaveBeenLastCalledWith` pour tester les arguments avec lesquels elle a été appelée en dernier. Par exemple, disons que vous avez une fonction `applyToAllFlavors(f)` qui applique `f` à un ensemble de saveurs, et que vous voulez vous assurer que lorsque vous l'appelez, la dernière saveur sur laquelle elle fonctionne est `'mango`. Vous pouvez écrire :

```js
test('applying to all flavors does mango last', () => {
  const drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith('mango');
});
```

### `.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)`

Également sous l'alias : `.nthCalledWith(nthCall, arg1, arg2, ...)`

Si vous avez une fonction fictive, vous pouvez utiliser `.toHaveBeenNthCalledWith` pour tester les arguments avec lesquels elle a été appelée. Par exemple, supposons que vous ayez une fonction `drinkEach(drink, Array<flavor>)` qui applique `f` à un ensemble de saveurs, et que vous vouliez vous assurer que lorsque vous l'appelez, la première saveur sur laquelle elle fonctionne est ``lemon`` et la seconde est 'octopus'. Vous pouvez écrire :

```js
test('drinkEach drinks each drink', () => {
  const drink = jest.fn();
  drinkEach(drink, ['lemon', 'octopus']);
  expect(drink).toHaveBeenNthCalledWith(1, 'lemon');
  expect(drink).toHaveBeenNthCalledWith(2, 'octopus');
});
```

Note : le nième argument doit être un nombre entier positif à partir de 1.

### `.toHaveReturned()`

Également sous l'alias : `.toReturn()`

Si vous disposez d'une fonction fictive, vous pouvez utiliser `.toHaveReturned` pour tester que la fonction fictive est bien retournée (c'est-à-dire qu'elle n'a pas lancé d'erreur) au moins une fois. Par exemple, disons que vous avez une "boisson" fictive qui renvoie `true`. Vous pouvez écrire :

```js
test('drinks returns', () => {
  const drink = jest.fn(() => true);

  drink();

  expect(drink).toHaveReturned();
});
```

### `.toHaveReturnedTimes(number)`

Également sous l'alias : `.toReturnTimes(number)`

Utilisez `.toHaveReturnedTimes` pour vous assurer qu'une fonction fictive est retournée avec succès (c'est-à-dire qu'elle n'a pas lancé d'erreur) un nombre exact de fois. Tout appel à la fonction fictive qui provoque une erreur n'est pas comptabilisé dans le nombre de fois où la fonction est retournée.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie ``true``. Vous pouvez écrire :

```js
test('drink returns twice', () => {
  const drink = jest.fn(() => true);

  drink();
  drink();

  expect(drink).toHaveReturnedTimes(2);
});
```

### `.toHaveReturnedWith(value)`

Également sous l'alias : `.toReturnWith(value)`

Utilisez `.toHaveReturnedWith` pour vous assurer qu'une fonction fictive renvoie une valeur spécifique.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns La Croix', () => {
  const beverage = {name: 'La Croix'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage);

  expect(drink).toHaveReturnedWith('La Croix');
});
```

### `.toHaveLastReturnedWith(value)`

Également sous l'alias : `.lastReturnedWith(value)`

Utilisez `.toHaveLastReturnedWith` pour tester la valeur spécifique qu'une fonction fictive a renvoyée en dernier. Si le dernier appel à la fonction fictive a provoqué une erreur, alors ce comparateur échouera, quelle que soit la valeur que vous avez fournie comme valeur de retour attendue.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns La Croix (Orange) last', () => {
  const beverage1 = {name: 'La Croix (Lemon)'};
  const beverage2 = {name: 'La Croix (Orange)'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveLastReturnedWith('La Croix (Orange)');
});
```

### `.toHaveNthReturnedWith(nthCall, value)`

Également sous l'alias : `.nthReturnedWith(nthCall, value)`

Utilisez `.toHaveNthReturnedWith` pour tester la valeur spécifique qu'une fonction fictive a renvoyée pour le nième appel. Si le nième appel à la fonction fictive a lancé une erreur, alors ce comparateur échouera quelle que soit la valeur que vous avez fournie comme valeur de retour attendue.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns expected nth calls', () => {
  const beverage1 = {name: 'La Croix (Lemon)'};
  const beverage2 = {name: 'La Croix (Orange)'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)');
  expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');
});
```

Note : le nième argument doit être un nombre entier positif à partir de 1.

### `.toHaveLength(number)`

Utilisez `.toHaveLength` pour vérifier qu'un objet a une propriété `.length` et qu'il est défini à une certaine valeur numérique.

Ceci est particulièrement utile pour vérifier la taille des tableaux ou des chaînes de caractères.

```js
expect([1, 2, 3]).toHaveLength(3);
expect('abc').toHaveLength(3);
expect('').not.toHaveLength(5);
```

### `.toHaveProperty(keyPath, value?)`

Utilisez `.toHaveProperty` pour vérifier si la propriété à la référence fournie `keyPath` existe pour un objet. Pour vérifier les propriétés profondément imbriquées dans un objet, vous pouvez utiliser la [notation par points](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors) ou un tableau contenant le keyPath pour les références profondes.

Vous pouvez fournir un argument optionnel "value" pour comparer la valeur de la propriété reçue (récursivement pour toutes les propriétés des instances d'un objet, également connu sous le nom d'égalité profonde, comme le comparateur "toEqual").

L'exemple suivant contient un objet "houseForSale" avec des propriétés imbriquées. Nous utilisons "toHaveProperty" pour vérifier l'existence et les valeurs des différentes propriétés de l'objet.

```js
// Object containing house features to be tested
const houseForSale = {
  bath: true,
  bedrooms: 4,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    area: 20,
    wallColor: 'white',
    'nice.oven': true,
  },
  'ceiling.height': 2,
};

test('this house has my desired features', () => {
  // Example Referencing
  expect(houseForSale).toHaveProperty('bath');
  expect(houseForSale).toHaveProperty('bedrooms', 4);

  expect(houseForSale).not.toHaveProperty('pool');

  // Deep referencing using dot notation
  expect(houseForSale).toHaveProperty('kitchen.area', 20);
  expect(houseForSale).toHaveProperty('kitchen.amenities', [
    'oven',
    'stove',
    'washer',
  ]);

  expect(houseForSale).not.toHaveProperty('kitchen.open');

  // Deep referencing using an array containing the keyPath
  expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20);
  expect(houseForSale).toHaveProperty(
    ['kitchen', 'amenities'],
    ['oven', 'stove', 'washer'],
  );
  expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven');
  expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']);
  expect(houseForSale).not.toHaveProperty(['kitchen', 'open']);

  // Referencing keys with dot in the key itself
  expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');
});
```

### `.toBeCloseTo(number, numDigits?)`

Utilisez `toBeCloseTo` pour comparer des nombres à virgule flottante pour une égalité approximative.

L'argument optionnel `numDigits` limite le nombre de chiffres à vérifier **après** la virgule décimale. Pour la valeur par défaut `2`, le critère de test est `Math.abs(expected - received) < 0.005` (c'est-à-dire `10 ** -2 / 2`).

Les comparaisons intuitives d'égalité échouent souvent, car l'arithmétique sur les valeurs décimales (base 10) comporte souvent des erreurs d'arrondi dans la représentation binaire de précision limitée (base 2). Par exemple, ce test échoue :

```js
test('adding works sanely with decimals', () => {
  expect(0.2 + 0.1).toBe(0.3); // Fails!
});
```

Il échoue parce qu'en JavaScript, `0.2 + 0.1` est en fait `0.30000000000000004`.

Par exemple, ce test est réussi avec une précision de 5 chiffres :

```js
test('adding works sanely with decimals', () => {
  expect(0.2 + 0.1).toBeCloseTo(0.3, 5);
});
```

Parce que les erreurs en virgule flottante sont le problème que `toBeCloseTo` résout, il ne supporte pas les grandes valeurs entières.

### `.toBeDefined()`

Utilisez `.toBeDefined` pour vérifier qu'une variable n'est pas indéfinie. Par exemple, si vous voulez vérifier qu'une fonction `fetchNewFlavorIdea()` renvoie _quelque chose_, vous pouvez écrire :

```js
test('there is a new flavor idea', () => {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
```

Vous pourriez écrire `expect(fetchNewFlavorIdea()).not.toBe(undefined)`, mais il est préférable d'éviter de faire référence à `undefined` directement dans votre code.

### `.toBeFalsy()`

Utilisez `.toBeFalsy` lorsque vous ne vous souciez pas de la valeur et que vous voulez vous assurer qu'une valeur est fausse dans un contexte booléen. Par exemple, disons que vous avez un code d'application qui ressemble à :

```js
drinkSomeLaCroix();
if (!getErrors()) {
  drinkMoreLaCroix();
}
```

Vous pouvez ne pas vous soucier de ce que `getErrors` renvoie, en particulier - il peut renvoyer `false`, `null`, ou `0`, et votre code fonctionnera quand même. Donc si vous voulez tester qu'il n'y a pas d'erreurs après avoir bu un peu de La Croix, vous pouvez écrire :

```js
test('drinking La Croix does not lead to errors', () => {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
```

En JavaScript, il y a six valeurs erronées : `false`, `0`, `''`, `null`, `undefined`, et `NaN`. Tout le reste est vrai.

### `.toBeGreaterThan(number | bigint)`

Utilisez `toBeGreaterThan` pour comparer `received > expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur de plus de 10 onces :

```js
test('ounces per can is more than 10', () => {
  expect(ouncesPerCan()).toBeGreaterThan(10);
});
```

### `.toBeGreaterThanOrEqual(number | bigint)`

Utilisez `toBeGreaterThanOrEqual` pour comparer `received <= expected` pour les nombres ou les grands nombres. Par exemple, testez que `ouncesPerCan()` renvoie une valeur d'au moins 12 onces :

```js
test('ounces per can is at least 12', () => {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(12);
});
```

### `.toBeLessThan(number | bigint)`

Utilisez `toBeLessThan` pour comparer `received < expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur inférieure à 20 onces :

```js
test('ounces per can is less than 20', () => {
  expect(ouncesPerCan()).toBeLessThan(20);
});
```

### `.toBeLessThanOrEqual(number | bigint)`

Utilisez `toBeLessThanOrEqual` pour comparer `received <= expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur d'au plus 12 onces :

```js
test('ounces per can is at most 12', () => {
  expect(ouncesPerCan()).toBeLessThanOrEqual(12);
});
```

### `.toBeInstanceOf(Class)`

Utilisez `.toBeInstanceOf(Class)` pour vérifier qu'un objet est une instance d'une classe. Ce comparateur utilise `instanceof` en dessous.

```js
class A {}

expect(new A()).toBeInstanceOf(A);
expect(() => {}).toBeInstanceOf(Function);
expect(new A()).toBeInstanceOf(Function); // throws
```

### `.toBeNull()`

`.toBeNull()` est le même que `.toBe(null)` mais les messages d'erreur sont un peu plus beaux. Utilisez donc `.toBeNull()` lorsque vous voulez vérifier que quelque chose est nul.

```js
function bloop() {
  return null;
}

test('bloop returns null', () => {
  expect(bloop()).toBeNull();
});
```

### `.toBeTruthy()`

Utilisez `.toBeTruthy` lorsque vous ne vous souciez pas de la valeur et que vous voulez vous assurer qu'une valeur est vraie dans un contexte booléen. Par exemple, disons que vous avez un code d'application qui ressemble à :

```js
drinkSomeLaCroix();
if (thirstInfo()) {
  drinkMoreLaCroix();
}
```

Vous pouvez ne pas vous soucier de ce que `thirstInfo` renvoie, en particulier - il pourrait renvoyer `true` ou un objet complexe, et votre code fonctionnerait toujours. Donc si vous voulez tester que `thirstInfo` sera vrai après avoir bu un peu de La Croix, vous pouvez écrire :

```js
test('drinking La Croix leads to having thirst info', () => {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
```

En JavaScript, il y a six valeurs erronées : `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Tout le reste est vrai.

### `.toBeUndefined()`

Utilisez "toBeUndefined" pour vérifier qu'une variable est bien indéfinie. Par exemple, si vous voulez vérifier qu'une fonction `bestDrinkForFlavor(flavor)` renvoie `undefined` pour la saveur `octopus`, parce qu'il n'y a pas de bonne boisson au goût de pieuvre :

```js
test('the best drink for octopus flavor is undefined', () => {
  expect(bestDrinkForFlavor('octopus')).toBeUndefined();
});
```

Vous pourriez écrire `expect(bestDrinkForFlavor('octopus')).toBe(undefined)`, mais il est préférable d'éviter de faire référence à `undefined` directement dans votre code.

### `.toBeNaN()`

Use `.toBeNaN` when checking a value is `NaN`.

```js
test('passes when value is NaN', () => {
  expect(NaN).toBeNaN();
  expect(1).not.toBeNaN();
});
```

### `.toContain(item)`

Utilisez `.toContain` lorsque vous voulez vérifier qu'un élément se trouve dans un tableau. Pour tester les éléments du tableau, on utilise `===`, une vérification stricte de l'égalité. Le `.toContain` peut également vérifier si une chaîne est une sous-chaîne d'une autre chaîne.

Par exemple, si `getAllFlavors()` renvoie un tableau de saveurs et que vous voulez être sûr que `lime` y est, vous pouvez écrire :

```js
test('the flavor list contains lime', () => {
  expect(getAllFlavors()).toContain('lime');
});
```

### `.toContainEqual(item)`

Utilisez `.toContainEqual` lorsque vous voulez vérifier qu'un élément avec une structure et des valeurs spécifiques est contenu dans un tableau. Pour tester les éléments dans le tableau, cet appariement vérifie récursivement l'égalité de tous les champs, plutôt que de vérifier l'identité de l'objet.

```js
describe('my beverage', () => {
  test('is delicious and not sour', () => {
    const myBeverage = {delicious: true, sour: false};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
```

### `.toEqual(value)`

Utilisez `.toEqual` pour comparer récursivement toutes les propriétés des instances d'objets (aussi appelé égalité "profonde"). Il appelle `Object.is` pour comparer les valeurs primitives, ce qui est encore mieux pour les tests que l'opérateur d'égalité stricte `===`.

Par exemple, `.toEqual` et `.toBe` se comportent différemment dans cette suite de tests, donc tous les tests passent :

```js
const can1 = {
  flavor: 'grapefruit',
  ounces: 12,
};
const can2 = {
  flavor: 'grapefruit',
  ounces: 12,
};

describe('the La Croix cans on my desk', () => {
  test('have all the same properties', () => {
    expect(can1).toEqual(can2);
  });
  test('are not the exact same can', () => {
    expect(can1).not.toBe(can2);
  });
});
```

> Note : `.toEqual` n'effectuera pas une vérification _profonde de l'égalité_ pour deux erreurs. Seule la propriété `message` d'une erreur est prise en compte pour l'égalité. Il est recommandé d'utiliser l'appariement `.toThrow` pour tester les erreurs.

Si les différences entre les propriétés ne vous aident pas à comprendre pourquoi un test échoue, en particulier si le rapport est volumineux, vous pouvez alors déplacer la comparaison dans la fonction "attendre". Par exemple, utilisez la méthode des "égaux" de la classe "buffer" pour déterminer si les tampons contiennent ou non le même contenu :

- réécrivez `expect(received).toEqual(expected)` comme `expect(received.equals(expected)).toBe(true)`.
- réécrire `expect(received).not.toEqual(expected)` comme `expect(received.equals(expected)).toBe(false)`.

### `.toMatch(regexpOrString)`

Utilisez `.toMatch` pour vérifier qu'une chaîne de caractères correspond à une expression régulière.

Par exemple, vous ne savez peut-être pas ce que retourne exactement `essayOnTheBestFlavor()`, mais vous savez que c'est une très longue chaîne, et que la sous-chaîne `grapefruit` devrait être là quelque part. Vous pouvez tester cela avec :

```js
describe('an essay on the best flavor', () => {
  test('mentions grapefruit', () => {
    expect(essayOnTheBestFlavor()).toMatch(/grapefruit/);
    expect(essayOnTheBestFlavor()).toMatch(new RegExp('grapefruit'));
  });
});
```

Ce jumelage accepte également avec une chaîne de caractère, qu'il essaiera de faire correspondre :

```js
describe('grapefruits are healthy', () => {
  test('grapefruits are a fruit', () => {
    expect('grapefruits').toMatch('fruit');
  });
});
```

### `.toMatchObject(object)`

Utilisez `.toMatchObject` pour vérifier qu'un objet JavaScript correspond à un sous-ensemble des propriétés d'un objet. Il fera correspondre les objets reçus avec les propriétés qui ne sont pas **non** dans l'objet attendu.

Vous pouvez également passer un tableau d'objets, auquel cas la méthode ne retournera vrai que si chaque objet du tableau reçu correspond (au sens "toMatchObject" décrit ci-dessus) à l'objet correspondant du tableau attendu. Ceci est utile si vous voulez vérifier que deux tableaux correspondent dans leur nombre d'éléments, par opposition à "arrayContaining", qui permet d'ajouter des éléments supplémentaires dans le tableau reçu.

Vous pouvez faire correspondre des propriétés à des valeurs ou à des éléments correspondants.

```js
const houseForSale = {
  bath: true,
  bedrooms: 4,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    area: 20,
    wallColor: 'white',
  },
};
const desiredHouse = {
  bath: true,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    wallColor: expect.stringMatching(/white|yellow/),
  },
};

test('the house has my desired features', () => {
  expect(houseForSale).toMatchObject(desiredHouse);
});
```

```js
describe('toMatchObject applied to arrays', () => {
  test('the number of elements must match exactly', () => {
    expect([{foo: 'bar'}, {baz: 1}]).toMatchObject([{foo: 'bar'}, {baz: 1}]);
  });

  test('.toMatchObject is called for each elements, so extra object properties are okay', () => {
    expect([{foo: 'bar'}, {baz: 1, extra: 'quux'}]).toMatchObject([
      {foo: 'bar'},
      {baz: 1},
    ]);
  });
});
```

### `.toMatchSnapshot(propertyMatchers?, hint?)`

Cela permet de s'assurer qu'une valeur correspond à l'instantané le plus récent. Consultez le [guide de test des instantanés] (SnapshotTesting.md) pour plus d'informations.

Vous pouvez fournir un argument optionnel pour l'objet `propertyMatchers`, qui a des matchers asymétriques comme valeurs d'un sous-ensemble de propriétés attendues, **si** la valeur reçue sera une instance **objet**. C'est comme un `toMatchObject` avec des critères flexibles pour un sous-ensemble de propriétés, suivi d'un test d'instantané comme critère exact pour le reste des propriétés.

Vous pouvez fournir un argument optionnel sous forme de chaîne de caractères "indice" qui est ajouté au nom du test. Bien que Jest ajoute toujours un nombre à la fin du nom de l'instantané, de courts indices descriptifs peuvent être plus utiles que des nombres pour différencier les **multiples** instantanés dans un bloc **single** `it` ou `test`. Jest trie les instantanés par nom dans le fichier ".snap" correspondant.

### `.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)`

S'assure qu'une valeur correspond à l'instantané le plus récent.

Vous pouvez fournir un argument optionnel pour l'objet `propertyMatchers`, qui a des matchers asymétriques comme valeurs d'un sous-ensemble de propriétés attendues, **si** la valeur reçue sera une instance **objet**. C'est comme un `toMatchObject` avec des critères flexibles pour un sous-ensemble de propriétés, suivi d'un test d'instantané comme critère exact pour le reste des propriétés.

Jest ajoute l'argument chaîne `inlineSnapshot` au matchcher dans le fichier de test (au lieu d'un fichier `.snap` externe) la première fois que le test est exécuté.

Consultez la section [Inline Snapshots](SnapshotTesting.md#inline-snapshots) pour plus d'informations.

### `.toStrictEqual(value)`

Utilisez `.toStrictEqual` pour tester que les objets ont les mêmes types ainsi que la même structure.

Différences par rapport à `.toEqual` :

- Les clés avec des propriétés `undefined` sont vérifiées. Par exemple, `{a : undefined, b : 2}` ne correspond pas à `{b: 2}` lorsque l'on utilise le `.toStrictEqual`.
- La dispersion des tableaux est vérifiée. par exemple, `[, 1]` ne correspond pas à `[undefined, 1]` quand on utilise `.toStrictEqual`.
- Les types d'objets sont vérifiés pour être égaux. Par exemple, une instance de classe avec les champs `a` et `b` ne sera pas égale à un objet littéral avec les champs `a` et `b`.

```js
class LaCroix {
  constructor(flavor) {
    this.flavor = flavor;
  }
}

describe('the La Croix cans on my desk', () => {
  test('are not semantically the same', () => {
    expect(new LaCroix('lemon')).toEqual({flavor: 'lemon'});
    expect(new LaCroix('lemon')).not.toStrictEqual({flavor: 'lemon'});
  });
});
```

### `.toThrow(error?)`

Également sous le pseudonyme : ".toThrowError(error ?)`

Utilisez `.toThrow` pour tester qu'une fonction lance lorsqu'elle est appelée. Par exemple, si nous voulons tester le lancer de `drinkFlavor('octopus')`, parce que la saveur du poulpe est trop dégoûtante pour être bue, nous pouvons écrire :

```js
test('throws on octopus', () => {
  expect(() => {
    drinkFlavor('octopus');
  }).toThrow();
});
```

> Note : Vous devez envelopper le code dans une fonction, sinon l'erreur ne sera pas détectée et l'assertion échouera.

Vous pouvez fournir un argument optionnel pour vérifier qu'une erreur spécifique est lancée :

- expression régulière : message d'erreur **correspond au modèle
- string : message d'erreur **inclut** la sous-chaîne
- objet d'erreur : le message d'erreur est **égale à** la propriété de message de l'objet
- classe d'erreur : l'objet d'erreur est **instance de** classe

Par exemple, disons que `drinkFlavor` est codé comme ceci :

```js
function drinkFlavor(flavor) {
  if (flavor == 'octopus') {
    throw new DisgustingFlavorError('yuck, octopus flavor');
  }
  // Faire d'autres choses
}
```

Nous pourrions tester cette erreur est jetée de plusieurs façons :

```js
test('throws on octopus', () => {
  function drinkOctopus() {
    drinkFlavor('octopus');
  }

  // Vérifiez que le message d'erreur dit "beurk" quelque part : ils sont équivalents
  expect(drinkOctopus).toThrowError(/yuck/);
  expect(drinkOctopus).toThrowError('yuck');

  // Tester le message d'erreur exact
  expect(drinkOctopus).toThrowError(/^yuck, octopus flavor$/);
  expect(drinkOctopus).toThrowError(new Error('yuck, octopus flavor'));

  // Tester que nous obtenons une erreur de goût dégoûtante
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
```

### `.toThrowErrorMatchingSnapshot(hint?)`

Utilisez `.toThrowErrorMatchingSnapshot` pour tester qu'une fonction lance une erreur correspondant à l'instantané le plus récent lorsqu'elle est appelée.

Vous pouvez fournir un argument optionnel sous forme de chaîne de caractères `hint` qui est ajouté au nom du test. Bien que Jest ajoute toujours un nombre à la fin du nom de l'instantané, de courts indices descriptifs peuvent être plus utiles que des nombres pour différencier les **multiples** instantanés dans un bloc **single** `it` ou `test`. Jest trie les instantanés par nom dans le fichier ".snap" correspondant.

Par exemple, disons que vous avez une fonction `drinkFlavor` qui lance chaque fois que la saveur est `'octopus'`, et qui est codée comme ceci :

```js
function drinkFlavor(flavor) {
  if (flavor == 'octopus') {
    throw new DisgustingFlavorError('yuck, octopus flavor');
  }
  // Faire d'autres choses
}
```

Le test de cette fonction se présentera ainsi :

```js
test('throws on octopus', () => {
  function drinkOctopus() {
    drinkFlavor('octopus');
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
```

Et il générera l'instantané suivant :

```js
exports[`drinking flavors throws on octopus 1`] = `"yuck, octopus flavor"`;
```

Consultez le site [React Tree Snapshot Testing] (https://jestjs.io/blog/2016/07/27/jest-14.html) pour plus d'informations sur les tests instantanés.

### `.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)`

Utilisez `.toThrowErrorMatchingInlineSnapshot` pour tester qu'une fonction lance une erreur correspondant à l'instantané le plus récent lorsqu'elle est appelée.

Jest ajoute l'argument chaîne `inlineSnapshot` au matcher dans le fichier de test (au lieu d'un fichier externe `.snap`) la première fois que le test est lancé.

Consultez la section [Inline Snapshots](SnapshotTesting.md#inline-snapshots) pour plus d'informations.
