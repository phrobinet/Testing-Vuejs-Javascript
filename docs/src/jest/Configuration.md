---
id: configuration
title: Configuring Jest
---

La configuration de Jest peut être définie dans le fichier `package.json` de votre projet, ou à travers un fichier `jest.config.js` ou à travers l'option `--config <path/to/file.js|cjs|mjs|json>`. Si vous souhaitez utiliser votre `package.json` pour stocker la configuration de Jest, la touche `"jest"` doit être utilisée au niveau supérieur pour que Jest sache comment trouver vos paramètres :

```json
{
  "name": "my-project",
  "jest": {
    "verbose": true
  }
}
```

Ou par le biais de JavaScript :

```js
// jest.config.js
//Sync object
module.exports = {
  verbose: true,
};

//Or async function
module.exports = async () => {
  return {
    verbose: true,
  };
};
```

Veuillez garder à l'esprit que la configuration résultante doit être compatible avec la série JSON.

Lorsque vous utilisez l'option `--config`, le fichier JSON ne doit pas contenir de clé "jest" :

```json
{
  "bail": 1,
  "verbose": true
}
```

## Options

Ces options vous permettent de contrôler le comportement de Jest dans votre fichier `package.json`. La philosophie de Jest est de fonctionner parfaitement par défaut, mais parfois vous avez juste besoin de plus de puissance de configuration.

### Defaults

Vous pouvez récupérer les options par défaut de Jest pour les développer si nécessaire :

```js
// jest.config.js
const {defaults} = require('jest-config');
module.exports = {
  // ...
  moduleFileExtensions: [...defaults.moduleFileExtensions, 'ts', 'tsx'],
  // ...
};
```

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Reference

### `automock` [boolean]

Par défaut : `false`

Cette option indique à Jest que tous les modules importés dans vos tests doivent être automatiquement simulés. Tous les modules utilisés dans vos tests auront une implémentation de remplacement, en gardant la surface de l'API.

Exemple :

```js
// utils.js
export default {
  authorize: () => {
    return 'token';
  },
  isAuthorized: secret => secret === 'wizard',
};
```

```js
//__tests__/automocking.test.js
import utils from '../utils';

test('if utils mocked automatically', () => {
  // Les méthodes publiques d'"utils" sont désormais des fonctions fictives
  expect(utils.authorize.mock).toBeTruthy();
  expect(utils.isAuthorized.mock).toBeTruthy();

  // Vous pouvez leur fournir votre propre mise en œuvre
  // ou dépasser la valeur de rendement attendue
  utils.authorize.mockReturnValue('mocked_token');
  utils.isAuthorized.mockReturnValue(true);

  expect(utils.authorize()).toBe('mocked_token');
  expect(utils.isAuthorized('not_wizard')).toBeTruthy();
});
```

-Note : les modules de nœuds sont automatiquement simulés lorsque vous avez mis en place une simulation manuelle (par exemple : `__mocks__/lodash.js`). Plus d'informations [ici](manual-mocks.html#mocking-node-modules)._

-Note : Les modules de base, comme `fs`, ne sont pas simulés par défaut. Ils peuvent être moqués explicitement, comme `jest.mock('fs')`._

### `bail` [number | boolean]

Par défaut : `0`

Par défaut, Jest exécute tous les tests et produit toutes les erreurs dans la console à la fin. L'option de configuration de la caution peut être utilisée ici pour que Jest arrête d'exécuter les tests après un échec. Mettre la caution à "true" est identique à mettre la caution à "1".

### `cacheDirectory` [string]

Par défaut : `"/tmp/<path>"`

Le répertoire où Jest doit stocker ses informations de dépendance en cache.

Jest tente d'analyser votre arborescence de dépendances une fois (en amont) et de la mettre en cache afin de faciliter le ratissage du système de fichiers qui doit avoir lieu pendant l'exécution des tests. Cette option de configuration vous permet de personnaliser l'endroit où Jest stocke ces données en cache sur le disque.

### `clearMocks` [boolean]

Par défaut : `false`

Effacer automatiquement les appels et les instances fictifs avant chaque test. Equivalent à appeler `jest.clearAllMocks()` avant chaque test. Cela ne supprime pas les implémentations fictives qui ont pu être fournies.

### `collectCoverage` [boolean]

Par défaut : `false`

Indique si les informations sur la couverture doivent être recueillies pendant l'exécution du test. Étant donné que tous les fichiers exécutés sont équipés de déclarations de collecte de couverture, cela peut ralentir considérablement vos tests.

### `collectCoverageFrom` [array]

Par défaut : `undefined`

Un tableau de [glob patterns] (https://github.com/jonschlinkert/micromatch) indiquant un ensemble de fichiers pour lesquels des informations de couverture doivent être collectées. Si un fichier correspond au modèle de globalité spécifié, les informations de couverture seront collectées pour ce fichier même s'il n'existe aucun test pour ce fichier et qu'il n'est jamais requis dans la suite de tests.

Exemple:

```json
{
  "collectCoverageFrom": [
    "**/*.{js,jsx}",
    "!**/node_modules/**",
    "!**/vendor/**"
  ]
}
```

Cela permettra de recueillir des informations sur la couverture de tous les fichiers contenus dans le "rootDir" du projet, à l'exception de ceux qui correspondent à `**/node_modules/**` ou `**/vendor/**`.

Note : Cette option nécessite que `collectCoverage` soit mis à true ou que Jest soit invoqué avec `--coverage`._

<details>
  <summary>Help:</summary>
  If you are seeing coverage output such as...

```
=============================== Coverage summary ===============================
Statements   : Unknown% ( 0/0 )
Branches     : Unknown% ( 0/0 )
Functions    : Unknown% ( 0/0 )
Lines        : Unknown% ( 0/0 )
================================================================================
Jest: Coverage data for global was not found.
```

Il est très probable que vos modèles de globes ne correspondent à aucun fichier. Consultez la documentation de [micromatch] (https://github.com/jonschlinkert/micromatch) pour vous assurer que vos globes sont compatibles.

</details>

### `coverageDirectory` [string]

Par défaut : `undefined`

Le répertoire où Jest doit produire ses fichiers de couverture.

### `coveragePathIgnorePatterns` [array\<string>]

Par défaut : `["/node_modules/"]`

Un ensemble de chaînes de motifs regexp qui sont comparées à tous les chemins d'accès aux fichiers avant d'exécuter le test. Si le chemin de fichier correspond à l'un des modèles, les informations sur la couverture seront ignorées.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le token de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/", "<répertoire racine>/node_modules/"]`.

### `coverageProvider` [string]

Indique quel fournisseur doit être utilisé pour instrumenter le code pour la couverture. Les valeurs autorisées sont "label" (par défaut) ou "v8".

Notez que l'utilisation de `v8` est considérée comme expérimentale. Il utilise la couverture du code intégré de V8 plutôt qu'un code basé sur Babel. Il n'est pas aussi bien testé, et il a également été amélioré dans les dernières versions de Node. L'utilisation des dernières versions de Node (v14 au moment où nous écrivons ces lignes) donnera de meilleurs résultats.

### `coverageReporters` [array\<string | [string, options]>]

Par défaut : `["json", "lcov", "text", "clover"]`

Une liste de noms de reporter que Jest utilise lors de la rédaction de ses reportages. Tout [reporter d'Istanbul] (https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib) peut être utilisé.

Remarque : le réglage de cette option écrase les valeurs par défaut. Ajoutez `"text"` ou `"text-summary"` pour voir un résumé de la couverture dans la sortie de la console._

Note : Vous pouvez passer des options supplémentaires au reporter d'istanbul en utilisant le formulaire des n-uplets. Par exemple:_
```json
["json", ["lcov", {"projectRoot": "../../"}]]
```

Pour plus d'informations sur la forme de l'objet options, vous pouvez vous référer au type "CoverageReporterWithOptions" dans le [type definitions] (https://github.com/facebook/jest/tree/master/packages/jest-types/src/Config.ts).

### `coverageThreshold` [object]

Par défaut : `undefined`

Cela servira à configurer le seuil minimum d'application pour les résultats de la couverture. Les seuils peuvent être spécifiés comme `global`, comme un [glob] (https://github.com/isaacs/node-glob#glob-primer), et comme un répertoire ou un chemin de fichier. Si les seuils ne sont pas atteints, la plaisanterie échouera. Les seuils spécifiés comme un nombre positif sont considérés comme étant le pourcentage minimum requis. Les seuils spécifiés comme un nombre négatif représentent le nombre maximum d'entités non couvertes autorisé.

Par exemple, avec la configuration suivante, jest échouera s'il y a moins de 80 % de branches, lignes et fonctions couvertes, ou s'il y a plus de 10 déclarations non couvertes :

```json
{
  ...
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": -10
      }
    }
  }
}
```

Si des globes ou des chemins sont spécifiés à côté de `global`, les données de couverture pour les chemins correspondants seront soustraites de la couverture globale et les seuils seront appliqués indépendamment. Les seuils pour les globs sont appliqués à tous les fichiers correspondant au global. Si le fichier spécifié par le chemin n'est pas trouvé, une erreur est renvoyée.

Par exemple, avec la configuration suivante :

```json
{
  ...
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 50,
        "functions": 50,
        "lines": 50,
        "statements": 50
      },
      "./src/components/": {
        "branches": 40,
        "statements": 40
      },
      "./src/reducers/**/*.js": {
        "statements": 90
      },
      "./src/api/very-important-module.js": {
        "branches": 100,
        "functions": 100,
        "lines": 100,
        "statements": 100
      }
    }
  }
}
```

Jest échouera si :

- Le répertoire `./src/components` a moins de 40% de couverture de branches ou d'énoncés.
- Un des fichiers correspondant au répertoire `./src/reducers/**/*.js` glob a une couverture de moins de 90%.
- Le fichier `./src/api/very-important-module.js` a une couverture inférieure à 100%.
- Tous les autres fichiers combinés ont une couverture inférieure à 50 % (`global`).

### `dependencyExtractor` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un extracteur de dépendance personnalisé. Il doit s'agir d'un module de noeud qui exporte un objet avec une fonction `extraire`. Par exemple :

```javascript
const fs = require('fs');
const crypto = require('crypto');

module.exports = {
  extract(code, filePath, defaultExtract) {
    const deps = defaultExtract(code, filePath);
    // Scanner le fichier et ajouter des dépendances dans `deps` (qui est un `Set`)
    return deps;
  },
  getCacheKey() {
    return crypto
      .createHash('md5')
      .update(fs.readFileSync(__filename))
      .digest('hex');
  },
};
```

La fonction `extract` devrait retourner un itérable (`Array`, `Set`, etc.) avec les dépendances trouvées dans le code.

Ce module peut également contenir une fonction `getCacheKey` pour générer une clé de cache afin de déterminer si la logique a changé et si les artefacts de cache qui en dépendent doivent être éliminés.

### `displayName` [string, object]

Par défaut : `undefined`

Permet d'imprimer une étiquette à côté d'un test en cours d'exécution. Cela devient plus utile dans les dépôts multi-projets où il peut y avoir de nombreux fichiers de configuration de blagues. Cela permet de savoir visuellement à quel projet appartient un test. Voici des exemples de valeurs valides.

```js
module.exports = {
  displayName: 'CLIENT',
};
```

ou

```js
module.exports = {
  displayName: {
    name: 'CLIENT',
    color: 'blue',
  },
};
```

Comme option secondaire, un objet avec les propriétés `name` et `color` peut être passé. Cela permet une configuration personnalisée de la couleur de fond du displayName. Par défaut, `displayName` est blanc lorsque sa valeur est une chaîne de caractères. Jest utilise [chalk](https://github.com/chalk/chalk) pour fournir la couleur. Ainsi, toutes les options valides pour les couleurs supportées par la craie sont également supportées par jest.

### `errorOnDeprecated` [boolean]

Par défaut : `false`

Faite en sorte que les API obsolètes envoient des messages d'erreur utiles. Utile pour faciliter le processus de mise à niveau.

### `extraGlobals` [array\<string>]

Par défaut : `undefined`

Les fichiers de test s'exécutent dans un [vm](https://nodejs.org/api/vm.html), qui ralentit les appels aux propriétés du contexte global (par exemple `Math`). Avec cette option, vous pouvez spécifier des propriétés supplémentaires à définir à l'intérieur du vm pour des recherches plus rapides.

Par exemple, si vos tests appellent souvent `Math`, vous pouvez le passer en définissant `extraGlobals`.

```json
{
  ...
  "jest": {
    "extraGlobals": ["Math"]
  }
}
```

### `forceCoverageMatch` [array\<string>]

Par défaut : `['']`

Les fichiers de test sont normalement ignorés lors de la collecte de la couverture de code. Avec cette option, vous pouvez écraser ce comportement et inclure les fichiers autrement ignorés dans la couverture de code.

Par exemple, si vous avez des tests dans des fichiers sources nommés avec l'extension `.t.js` comme suit :

```javascript
// sum.t.js

export function sum(a, b) {
  return a + b;
}

if (process.env.NODE_ENV === 'test') {
  test('sum', () => {
    expect(sum(1, 2)).toBe(3);
  });
}
```

Vous pouvez collecter la couverture de ces fichiers avec le paramètre `forceCoverageMatch`.

```json
{
  ...
  "jest": {
    "forceCoverageMatch": ["**/*.t.js"]
  }
}
```

### `globals` [object]

Par défaut : `{}`

Un ensemble de variables globales qui doivent être disponibles dans tous les environnements de test.

Par exemple, ce qui suit créerait une variable globale `__DEV__` définie comme `vrai` dans tous les environnements de test :

```json
{
  ...
  "jest": {
    "globals": {
      "__DEV__": true
    }
  }
}
```

Notez que, si vous spécifiez une valeur de référence globale (comme un objet ou un tableau) ici, et que certains codes mutent cette valeur au milieu de l'exécution d'un test, cette mutation ne sera _pas_ persistante d'une exécution à l'autre pour les autres fichiers de test. De plus, l'objet `global` doit être sérialisable en json, il ne peut donc pas être utilisé pour spécifier des fonctions globales. Pour cela, vous devez utiliser les `setupFiles`.

### `globalSetup` [string]

Par défaut : `undefined`

Cette option permet d'utiliser un module de configuration globale personnalisé qui exporte une fonction asynchrone qui est déclenchée une fois avant toutes les suites de tests. Cette fonction reçoit l'objet "GlobalConfig" de Jest comme paramètre.

Note : Un module de configuration globale configuré dans un projet (utilisant un runner multi-projets) ne sera déclenché que si vous exécutez au moins un test de ce projet.

Note : Toutes les variables globales qui sont définies par `globalSetup` ne peuvent être lues que dans `globalTeardown`. Vous ne pouvez pas récupérer les variables globales définies ici dans vos suites de test.

Note : Alors que la transformation de code est appliquée au fichier de configuration lié, Jest ne transformera **pas** de code dans les `node_modules`. Ceci est dû à la nécessité de charger les transformateurs réels (par exemple `babel` ou `typescript`) pour effectuer la transformation._

Exemple:

```js
// setup.js
module.exports = async () => {
  // ...
  // Mettre la référence à mongod afin de fermer le serveur pendant le démontage.
  global.__MONGOD__ = mongod;
};
```

```js
// teardown.js
module.exports = async function () {
  await global.__MONGOD__.stop();
};
```

### `globalTeardown` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un module de démontage global personnalisé qui exporte une fonction d'asynchronisation qui est déclenchée une fois après toutes les suites de tests. Cette fonction reçoit l'objet "GlobalConfig" de Jest comme paramètre.

Note : Un module de démontage global configuré dans un projet (utilisant un runner multi-projets) ne sera déclenché que si vous exécutez au moins un test à partir de ce projet.

Note : La même mise en garde concernant la transformation des `node_modules` que pour `globalSetup` s'applique à `globalTeardown`._

### `maxConcurrency` [number]

Par défaut : `5`

Un nombre limitant le nombre de tests autorisés à être exécutés en même temps lors de l'utilisation de `test.concurrent`. Tout test dépassant cette limite sera mis en file d'attente et exécuté une fois qu'un créneau est libéré.

### `moduleDirectories` [array\<string>]

Par défaut : `["node_modules"]`

Un tableau de noms de répertoires à rechercher récursivement vers le haut à partir de l'emplacement du module requis. Le réglage de cette option _remplace_ la valeur par défaut, si vous souhaitez toujours rechercher des `node_modules` pour les paquets l'incluent avec toute autre option : ["node_modules", "bower_components"].

### `moduleFileExtensions` [array\<string>]

Par défaut : `["js", "json", "jsx", "ts", "tsx", "node"]`

Une série d'extensions de fichiers que vos modules utilisent. Si vous avez besoin de modules sans spécifier d'extension de fichier, voici les extensions que Jest recherchera, dans l'ordre de gauche à droite.

Nous vous recommandons de placer les extensions les plus couramment utilisées dans votre projet sur la gauche, donc si vous utilisez le TypeScript, vous pouvez envisager de déplacer "ts" et/ou "tsx" au début du tableau.

### `moduleNameMapper` [object\<string, string | array\<string>>]

Default: `null`

Une carte allant des expressions régulières aux noms de modules ou aux tableaux de noms de modules qui permettent de tronquer des ressources, comme des images ou des styles, avec un seul module.

Les modules qui sont mappés à un alias sont démotivés par défaut, que l'auto-modélisation soit activée ou non.

Utilisez le conteneur de chaîne `<rootDir>` pour faire référence à la valeur de [`rootDir`](#rootdir-string) si vous voulez utiliser des chemins de fichiers.

De plus, vous pouvez substituer les groupes de regex capturés en utilisant des références numérotées.

Exemple:

```json
{
  "moduleNameMapper": {
    "^image![a-zA-Z0-9$_-]+$": "GlobalImageStub",
    "^[./a-zA-Z0-9$_-]+\\.png$": "<rootDir>/RelativeImageStub.js",
    "module_name_(.*)": "<rootDir>/substituted_module_$1.js",
    "assets/(.*)": [
      "<rootDir>/images/$1",
      "<rootDir>/photos/$1",
      "<rootDir>/recipes/$1"
    ]
  }
}
```

L'ordre dans lequel les cartographies sont définies est important. Les modèles sont vérifiés un par un jusqu'à ce que l'un d'entre eux corresponde. La règle la plus spécifique doit être mentionnée en premier. Ceci est également vrai pour les tableaux de noms de modules.

Note : Si vous fournissez un nom de module sans limites, cela peut causer des erreurs difficiles à repérer. Par exemple, `relay` remplacera tous les modules qui contiennent `relay` comme sous-chaîne dans leur nom : `relay`, `react-relay` et `graphql-relay` seront tous dirigés vers votre talon.

### `modulePathIgnorePatterns` [array\<string>]

Par défaut : `[]`

Un tableau de chaînes de motifs regexp qui sont comparées à tous les chemins de module avant que ces chemins ne soient considérés comme "visibles" pour le chargeur de module. Si le chemin d'un module donné correspond à l'un des motifs, il ne sera pas `require()`able dans l'environnement de test.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/"]`.

### `modulePaths` [array\<string>]

Par défaut : `[]`

Une API alternative au paramétrage de la variable `NODE_PATH` env, `modulePaths` est un tableau de chemins absolus vers des emplacements supplémentaires à rechercher lors de la résolution de modules. Utilisez le token de chaîne `<rootDir>` pour inclure le chemin vers le répertoire racine de votre projet. Exemple : `["<rootDir>/app/"]`.

### `notify` [boolean]

Par défaut : `false`

Active les notifications des résultats des tests.

**Attention : Jest utilise [node-notifier] (https://github.com/mikaelbr/node-notifier) pour afficher les notifications sur le bureau. Sous Windows, il crée une nouvelle entrée dans le menu de démarrage lors de la première utilisation et n'affiche pas la notification. Les notifications seront correctement affichées lors des exécutions suivantes.

### `notifyMode` [string]

Par défaut : `failure-change`

Précise le mode de notification. Requiert "notify : true".

#### Modes

- `always`: toujours envoyer une notification.
- `failure`: envoie une notificqtion lorsque les tests échouent
- `success`: envoie une notification lorsque les tests réussissent.
- `change`: envoie une notification quans le status à changé.
- `success-change`: envoie une notification quans les tests réussissent ou une fois quand ils échouent.
- `failure-change`: envoie une notification quand les tests échouent ou une fois lorsqu'il réussissent.

### `preset` [string]

Par défaut : `undefined`

Un préréglage qui sert de base à la configuration de Jest. Un preset doit pointer vers un module npm qui a un fichier `jest-preset.json` ou `jest-preset.js` à la racine.

Par exemple, ce preset `foo-bar/jest-preset.js` sera configuré comme suit :

```json
{
  "preset": "foo-bar"
}
```

Les préréglages peuvent également être relatifs aux chemins du système de fichiers.

```json
{
  "preset": "./node_modules/foo-bar/jest-preset.js"
}
```

### `prettierPath` [string]

Par défaut : `'prettier'`

Définit le chemin d'accès au module du nœud [`prettier`](https://prettier.io/) utilisé pour mettre à jour les instantanés en ligne.

### `projects` [array\<string | ProjectConfig>]

Par defaut : `undefined`

Lorsque la configuration des "projets" est fournie avec un tableau de chemins ou de modèles de globes, Jest effectuera des tests dans tous les projets spécifiés en même temps. C'est idéal pour les monorepos ou lorsque l'on travaille sur plusieurs projets en même temps.

```json
{
  "projects": ["<rootDir>", "<rootDir>/examples/*"]
}
```

Cette configuration d'exemple exécutera Jest dans le répertoire racine ainsi que dans chaque dossier du répertoire exemples. Vous pouvez avoir un nombre illimité de projets en cours d'exécution dans la même instance de Jest.

La fonction projets peut également être utilisée pour exécuter plusieurs configurations ou plusieurs [runners](#runner-string). Pour cela, vous pouvez passer un tableau d'objets de configuration. Par exemple, pour exécuter à la fois des tests et ESLint (via [jest-runner-eslint](https://github.com/jest-community/jest-runner-eslint)) dans la même invocation de Jest :

```json
{
  "projects": [
    {
      "displayName": "test"
    },
    {
      "displayName": "lint",
      "runner": "jest-runner-eslint",
      "testMatch": ["<rootDir>/**/*.js"]
    }
  ]
}
```

Note : Lorsque vous utilisez un runner multi-projets, il est recommandé d'ajouter un `displayName` pour chaque projet. Cela affichera le `displayName` d'un projet à côté de ses tests._

### `reporters` [array\<moduleName | [moduleName, options]>]

Par défaut : `undefined`

Utilisez cette option de configuration pour ajouter des reporters personnalisés à Jest. Un rapporteur personnalisé est une classe qui implémente les méthodes `onRunStart`, `onTestStart`, `onTestResult`, `onRunComplete` qui seront appelées lorsque l'un de ces événements se produira.

Si des reporters personnalisés sont spécifiés, les reporters Jest par défaut seront remplacés. Pour conserver les rapporteurs par défaut, `default` peut être passé comme nom de module.

Ceci remplacera les rapporteurs par défaut :

```json
{
  "reporters": ["<rootDir>/my-custom-reporter.js"]
}
```

Ce système utilisera un rapporteur personnalisé en plus des rapporteurs par défaut que Jest fournit :

```json
{
  "reporters": ["default", "<rootDir>/my-custom-reporter.js"]
}
```

De plus, les rapporteurs personnalisés peuvent être configurés en passant un objet "options" comme second argument :

```json
{
  "reporters": [
    "default",
    ["<rootDir>/my-custom-reporter.js", {"banana": "yes", "pineapple": "no"}]
  ]
}
```

Les modules reporters personnalisés doivent définir une classe qui prend un `GlobalConfig` et des options reporters comme arguments de construction :

Exemple de rapporteur :

```js
// my-custom-reporter.js
class MyCustomReporter {
  constructor(globalConfig, options) {
    this._globalConfig = globalConfig;
    this._options = options;
  }

  onRunComplete(contexts, results) {
    console.log('Custom reporter output:');
    console.log('GlobalConfig: ', this._globalConfig);
    console.log('Options: ', this._options);
  }
}

module.exports = MyCustomReporter;
// or export default MyCustomReporter;
```

Les reporters personnalisés peuvent également forcer Jest à sortir avec un code non-0 en retournant une erreur des méthodes `getLastError()`.

```js
class MyCustomReporter {
  // ...
  getLastError() {
    if (this._shouldFail) {
      return new Error('my-custom-reporter.js reported an error');
    }
  }
}
```

Pour la liste complète des méthodes et des types d'arguments, voir l'interface `Reporter` dans [packages/jest-reporters/src/types.ts](https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts)

### `resetMocks` [boolean]

Par défaut : `false`

Réinitialisation automatique de l'état simulé avant chaque test. Equivalent à appeler `jest.resetAllMocks()` avant chaque test. Cela conduit à la suppression des fausses implémentations de tous les mocks, mais ne rétablit pas leur implémentation initiale.

### `resetModules` [boolean]

Par défaut : `false`

Par défaut, chaque fichier de test reçoit son propre registre de module indépendant. L'activation de `resetModules` va plus loin et réinitialise le registre de module avant de lancer chaque test individuel. Ceci est utile pour isoler les modules pour chaque test afin que l'état local du module ne soit pas en conflit entre les tests. Cela peut être fait par programmation en utilisant [`jest.resetModules()`](JestObjectAPI.md#jestresetmodules).

### `resolver` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un résolveur personnalisé. Ce résolveur doit être un module de noeud qui exporte une fonction en attendant une chaîne de caractères comme premier argument pour le chemin à résoudre et un objet avec la structure suivante comme deuxième argument :

```json
{
  "basedir": string,
  "defaultResolver": "function(request, options)",
  "extensions": [string],
  "moduleDirectory": [string],
  "paths": [string],
  "packageFilter": "function(pkg, pkgdir)",
  "rootDir": [string]
}
```

La fonction doit soit renvoyer un chemin d'accès au module qui doit être résolu, soit lancer une erreur si le module ne peut être trouvé.

Note : le résolveur par défaut passé en option est le résolveur par défaut Jest qui peut être utile lorsque vous écrivez votre propre résolution. Il prend les mêmes arguments que votre résolution personnalisée, par exemple `(request, options)`.

Par exemple, si vous voulez respecter le champ [``navigateur`` de Browserify](https://github.com/browserify/browserify-handbook/blob/master/readme.markdown#browser-field), vous pouvez utiliser la configuration suivante :

```json
{
  ...
  "jest": {
    "resolver": "browser-resolve"
  }
}
```

En combinant `defaultResolver` et `packageFilter`, nous pouvons implémenter un `package.json` "pré-processeur" qui nous permet de changer la façon dont le résolveur par défaut résoudra les modules. Par exemple, imaginez que nous voulions utiliser le champ `"module"` s'il est présent, sinon, revenez à `"main"` :

```json
{
  ...
  "jest": {
    "resolver": "my-module-resolve"
  }
}
```

```js
// my-module-resolve package

module.exports = (request, options) => {
  // Appeler le defaultResolver, afin d'exploiter son cache, la gestion des erreurs, etc.
  return options.defaultResolver(request, {
    ...options,
    // Utiliser packageFilter pour traiter le `package.json` analysé avant la résolution (voir https://www.npmjs.com/package/resolve#resolveid-opts-cb)
    packageFilter: pkg => {
      return {
        ...pkg,
        // Modifier la valeur de "main" avant de résoudre le paquet
        main: pkg.module || pkg.main,
      };
    },
  });
};
```

### `restoreMocks` [boolean]

Par défaut : `false`

Restaurer automatiquement l'état de simulation avant chaque test. Equivalent à appeler `jest.restoreAllMocks()` avant chaque test. Cela permet de supprimer les fausses implémentations de tous les mocks et de restaurer leur implémentation initiale.

### `rootDir` [string]

Par défaut : La racine du répertoire contenant votre Jest [fichier de configuration](#) _ou_ le `package.json` _ou_ le [`pwd`](http://en.wikipedia.org/wiki/Pwd) si aucun `package.json` n'est trouvé

Le répertoire racine que Jest doit analyser pour les tests et les modules qui s'y trouvent. Si vous mettez votre configuration Jest dans votre `package.json` et que vous voulez que le répertoire racine soit la racine de votre repo, la valeur de ce paramètre de configuration sera par défaut le répertoire du `package.json`.

Souvent, vous voudrez mettre ce paramètre à `src'` ou `'lib'`, correspondant à l'endroit où le code est stocké dans votre dépôt.

_Notez que l'utilisation de `'<rootDir>'` comme chaîne de caractères dans tout autre paramètre de configuration basé sur le chemin d'accès fera référence à cette valeur. Ainsi, par exemple, si vous voulez que votre entrée de configuration [`setupFiles`](#setupfiles-array) pointe sur le fichier `env-setup.js` à la racine de votre projet, vous pouvez définir sa valeur à `["<rootDir>/env-setup.js"]`._

### `roots` [array\<string>]

Par défaut : `["<rootDir>"]`

Une liste de chemins d'accès aux répertoires que Jest doit utiliser pour rechercher des fichiers dans.

Il peut arriver que vous vouliez que Jest ne cherche que dans un seul sous-répertoire (par exemple, si vous avez un répertoire "src/" dans votre repo), mais que vous l'empêchiez d'accéder au reste du repo.

_Note : Alors que `rootDir` est principalement utilisé comme un jeton à réutiliser dans d'autres options de configuration, `roots` est utilisé par les internes de Jest pour localiser les **fichiers de test et les fichiers sources**. Cela s'applique également à la recherche de modules manuels pour les modules de `node_modules` (`__mocks__` devront vivre dans une des `roots`)._

_Note : Par défaut, `roots` a une seule entrée `<rootDir>` mais il y a des cas où vous pouvez vouloir avoir plusieurs racines dans un même projet, par exemple `roots : ["<rootDir>/src/", "<rootDir>/tests/"]`._

### `runner` [string]

Par défaut : `"jest-runner"`

Cette option vous permet d'utiliser un runner personnalisé au lieu du runner de test par défaut de Jest. Voici quelques exemples de runners :

- [`jest-runner-eslint`](https://github.com/jest-community/jest-runner-eslint)
- [`jest-runner-mocha`](https://github.com/rogeliog/jest-runner-mocha)
- [`jest-runner-tsc`](https://github.com/azz/jest-runner-tsc)
- [`jest-runner-prettier`](https://github.com/keplersj/jest-runner-prettier)

_Note : La valeur de la propriété "runner" peut omettre le préfixe "jest-runner-" du nom du paquet._

Pour écrire un test-runner, exportez une classe qui accepte `globalConfig` dans le constructeur, et qui a une méthode `runTests` avec la signature :

```ts
async runTests(
  tests: Array<Test>,
  watcher: TestWatcher,
  onStart: OnTestStart,
  onResult: OnTestSuccess,
  onFailure: OnTestFailure,
  options: TestRunnerOptions,
): Promise<void>
```

Si vous avez besoin de limiter votre test-runner à fonctionner en série plutôt qu'en parallèle, votre classe doit avoir la propriété `isSerial` pour être définie comme `true`.

### `setupFiles` [array]

Par défaut : `[]`

Une liste de chemins d'accès aux modules qui exécutent du code pour configurer ou mettre en place l'environnement de test. Chaque setupFile sera exécuté une fois par fichier de test. Comme chaque test s'exécute dans son propre environnement, ces scripts seront exécutés dans l'environnement de test immédiatement avant l'exécution du code de test lui-même.

Il est également intéressant de noter que les `setupFiles` s'exécuteront _avant_ [`setupFilesAfterEnv`](#setupfilesafterenv-array).

### `setupFilesAfterEnv` [array]

Default: `[]`

Une liste de chemins d'accès aux modules qui exécutent du code pour configurer ou mettre en place le cadre de test avant que chaque fichier de test de la suite ne soit exécuté. Puisque [`setupFiles`](#setupfiles-array) s'exécute avant que le cadre de test soit installé dans l'environnement, ce fichier de script vous offre la possibilité d'exécuter du code immédiatement après l'installation du cadre de test dans l'environnement.

Si vous voulez qu'un chemin soit [relatif au répertoire racine de votre projet](#rootdir-string), veuillez inclure `<rootDir>` dans une chaîne de chemin, comme `"<rootDir>/a-configs-folder"`.

Par exemple, Jest est livré avec plusieurs plug-ins pour "jasmine" qui fonctionnent en patchant l'API de jasmine. Si vous souhaitez ajouter encore plus de plugins jasmin au mélange (ou si vous voulez des matchers personnalisés pour l'ensemble du projet par exemple), vous pouvez le faire dans ces modules.

-Note : `setupTestFrameworkScriptFile` est déprécié en faveur de `setupFilesAfterEnv`._

Exemple `setupFilesAfterEnv` un tableau dans un jest.config.js:

```js
module.exports = {
  setupFilesAfterEnv: ['./jest.setup.js'],
};
```

Exemple le fichier `jest.setup.js`

```js
jest.setTimeout(10000); // in milliseconds
```

### `slowTestThreshold` [number]

Par défaut : `5`

Le nombre de secondes après lequel un test est considéré comme lent et signalé comme tel dans les résultats.

### `snapshotResolver` [string]

Par défaut : `undefined`

Le chemin vers un module qui peut résoudre le chemin test<->snapshot. Cette option de configuration vous permet de personnaliser l'endroit où Jest stocke les fichiers d'instantanés sur le disque.

Exemple de module de résolution d'instantanés :

```js
module.exports = {
  // passe du test à l'instantané
  resolveSnapshotPath: (testPath, snapshotExtension) =>
    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,

  // se résout de l'instantané à la voie de test
  resolveTestPath: (snapshotFilePath, snapshotExtension) =>
    snapshotFilePath
      .replace('__snapshots__', '__tests__')
      .slice(0, -snapshotExtension.length),

  // Exemple de parcours de test, utilisé pour le contrôle de cohérence avant vol de la mise en œuvre ci-dessus
  testPathForConsistencyCheck: 'some/__tests__/example.test.js',
};
```

### `snapshotSerializers` [array\<string>]

Par défaut : `[]`

Une liste de chemins d'accès aux modules de sérialisation des instantanés que Jest devrait utiliser pour les tests d'instantanés.

Jest dispose de sérialiseurs par défaut pour les types JavaScript intégrés, les éléments HTML (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) et pour les éléments React. Voir le [tutoriel de test instantané] (TutorialReactNative.md#snapshot-test) pour plus d'informations.

Exemple de module de sérialisation :

```js
// my-serializer-module
module.exports = {
  serialize(val, config, indentation, depth, refs, printer) {
    return 'Pretty foo: ' + printer(val.foo);
  },

  test(val) {
    return val && val.hasOwnProperty('foo');
  },
};
```

`printer` est une fonction qui sérialise une valeur en utilisant des plugins existants.

Pour utiliser `my-serializer-module` comme sérialiseur, la configuration serait la suivante :

```json
{
  ...
  "jest": {
    "snapshotSerializers": ["my-serializer-module"]
  }
}
```

Enfin, les tests se présenteraient comme suit :

```js
test(() => {
  const bar = {
    foo: {
      x: 1,
      y: 2,
    },
  };

  expect(bar).toMatchSnapshot();
});
```

Rendu instantané :

```json
Pretty foo: Object {
  "x": 1,
  "y": 2,
}
```

Pour rendre une dépendance explicite plutôt qu'implicite, vous pouvez appeler [`expect.addSnapshotSerializer`](ExpectAPI.md#expectaddsnapshotserializerserializer) pour ajouter un module pour un fichier de test individuel au lieu d'ajouter son chemin vers `snapshotSerializers` dans la configuration de Jest.

Pour en savoir plus sur l'API des sérialiseurs, voir [ici] (https://github.com/facebook/jest/tree/master/packages/pretty-format/README.md#serialize).

### `testEnvironment` [string]

Par défaut : `"jsdom"`

L'environnement de test qui sera utilisé pour les essais. L'environnement par défaut de Jest est un environnement de type navigateur via [jsdom] (https://github.com/jsdom/jsdom). Si vous construisez un service de noeud, vous pouvez utiliser l'option "node" pour utiliser un environnement de type noeud à la place.

En ajoutant un bloc de documentation "@jest environment" en haut du fichier, vous pouvez spécifier un autre environnement à utiliser pour tous les tests dans ce fichier :

```js
/**
 * @jest-environment jsdom
 */

test('use jsdom in this test file', () => {
  const element = document.createElement('div');
  expect(element).not.toBeNull();
});
```

Vous pouvez créer votre propre module qui sera utilisé pour mettre en place l'environnement de test. Le module doit exporter une classe avec les méthodes `setup`, `teardown` et `runScript`. Vous pouvez également passer des variables de ce module à vos suites de test en les assignant à l'objet `this.global` &ndash ; cela les rendra disponibles dans vos suites de test en tant que variables globales.

La classe peut éventuellement exposer une méthode asynchrone `handleTestEvent` pour se lier aux événements déclenchés par [`jest-circus`](https://github.com/facebook/jest/tree/master/packages/jest-circus). Normalement, le testeur de `jest-circus` ferait une pause jusqu'à ce qu'une promesse retournée par `handleTestEvent` soit remplie, **sauf pour les prochains événements** : `start_describe_definition`, `finish_describe_definition`, `add_hook`, `add_test` ou `error` (pour la liste à jour, vous pouvez consulter [SyncEvent type in the types definitions](https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts)). Cela est dû à des raisons de rétrocompatibilité et à la signature `process.on('unhandledRejection', callback)`, mais cela ne devrait généralement pas poser de problème dans la plupart des cas d'utilisation.

Tout pragmatisme de docblock dans les fichiers de test sera transmis au constructeur d'environnement et peut être utilisé pour la configuration par test. Si le pragmatisme n'a pas de valeur, il sera présent dans l'objet avec sa valeur fixée à une chaîne vide. Si le pragmatisme n'est pas présent, il ne sera pas présent dans l'objet.

_Note : TestEnvironment est un environnement "sandboxed". Chaque suite de test déclenchera la configuration/le démontage dans son propre TestEnvironment._

Exemple :

```js
// my-custom-environment
const NodeEnvironment = require('jest-environment-node');

class CustomEnvironment extends NodeEnvironment {
  constructor(config, context) {
    super(config, context);
    this.testPath = context.testPath;
    this.docblockPragmas = context.docblockPragmas;
  }

  async setup() {
    await super.setup();
    await someSetupTasks(this.testPath);
    this.global.someGlobalObject = createGlobalObject();

    // Will trigger if docblock contains @my-custom-pragma my-pragma-value
    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {
      // ...
    }
  }

  async teardown() {
    this.global.someGlobalObject = destroyGlobalObject();
    await someTeardownTasks();
    await super.teardown();
  }

  runScript(script) {
    return super.runScript(script);
  }

  async handleTestEvent(event, state) {
    if (event.name === 'test_start') {
      // ...
    }
  }
}

module.exports = CustomEnvironment;
```

```js
// my-test-suite
let someGlobalObject;

beforeAll(() => {
  someGlobalObject = global.someGlobalObject;
});
```

### `testEnvironmentOptions` [Object]

Par défaut : `{}`

Les options d'environnement de test qui seront transmises au "TestEnvironment". Les options pertinentes dépendent de l'environnement. Par exemple, vous pouvez remplacer les options données à [jsdom](https://github.com/jsdom/jsdom) telles que `{userAgent : "Agent/007"}`.

### `testMatch` [array\<string>]

(par défaut : "**/__tests__/**/*.[jt]s ?(x)", "**/ ?(*.)+(spec|test).[jt]s ?(x)") ]`)

Les modèles de globes que Jest utilise pour détecter les fichiers de test. Par défaut, il recherche les fichiers `.js`, `.jsx`, `.ts` et `.tsx` à l'intérieur des dossiers `__tests__`, ainsi que tout fichier portant le suffixe `.test` ou `.spec` (par exemple `Component.test.js` ou `Component.spec.js`). Il trouvera également des fichiers appelés `test.js` ou `spec.js`.

Voir le paquet [micromatch] (https://github.com/jonschlinkert/micromatch) pour plus de détails sur les modèles que vous pouvez spécifier.

Voir aussi [`testRegex` [string | array\<string>]](#testregex-string--arraystring), mais notez que vous ne pouvez pas spécifier les deux options.

### `testPathIgnorePatterns` [array\<string>]

Par défaut : `["/node_modules/"]`

Un tableau d'ensemble de chaînes regexp qui sont comparées à tous les chemins de test avant l'exécution du test. Si le chemin de test correspond à l'un des modèles, il sera ignoré.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/", "<répertoire racine>/node_modules/"]`.

### `testRegex` [string | array\<string>]

Par défaut : `(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$`

Le ou les modèles que Jest utilise pour détecter les fichiers tests. Par défaut, il recherche les fichiers `.js`, `.jsx`, `.ts` et `.tsx` à l'intérieur des dossiers `__tests__`, ainsi que tout fichier portant le suffixe `.test` ou `.spec` (par exemple `Component.test.js` ou `Component.spec.js`). Il trouvera également des fichiers appelés `test.js` ou `spec.js`. Voir aussi [`testMatch` [array\<string>]](#testmatch-arraystring), mais notez que vous ne pouvez pas spécifier les deux options.

Ce qui suit est une visualisation de la regex par défaut :

```bash
├── __tests__
│   └── component.spec.js # test
│   └── anything # test
├── package.json # not test
├── foo.test.js # test
├── bar.spec.jsx # test
└── component.js # not test
```

_Note : `testRegex` essaiera de détecter les fichiers de test en utilisant le **chemin de fichier absolu**, par conséquent, avoir un dossier avec un nom qui correspond lancera tous les fichiers comme tests_.

### `testResultsProcessor` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un processeur de résultats personnalisé. Ce processeur doit être un module de nœud qui exporte une fonction en attendant un objet ayant la structure suivante comme premier argument et le renvoie :

```json
{
  "success": bool,
  "startTime": epoch,
  "numTotalTestSuites": number,
  "numPassedTestSuites": number,
  "numFailedTestSuites": number,
  "numRuntimeErrorTestSuites": number,
  "numTotalTests": number,
  "numPassedTests": number,
  "numFailedTests": number,
  "numPendingTests": number,
  "numTodoTests": number,
  "openHandles": Array<Error>,
  "testResults": [{
    "numFailingTests": number,
    "numPassingTests": number,
    "numPendingTests": number,
    "testResults": [{
      "title": string (message in it block),
      "status": "failed" | "pending" | "passed",
      "ancestorTitles": [string (message in describe blocks)],
      "failureMessages": [string],
      "numPassingAsserts": number,
      "location": {
        "column": number,
        "line": number
      }
    },
    ...
    ],
    "perfStats": {
      "start": epoch,
      "end": epoch
    },
    "testFilePath": absolute path to test file,
    "coverage": {}
  },
  ...
  ]
}
```

### `testRunner` [string]

Par défaut : `jasmine2`

Cette option permet l'utilisation d'un testeur personnalisé. La valeur par défaut est jasmine2. Un programme de test personnalisé peut être fourni en spécifiant un chemin d'accès à une implémentation de programme de test.

Le module de l'exécuteur de test doit exporter une fonction avec la signature suivante :

```ts
function testRunner(
  globalConfig: GlobalConfig,
  config: ProjectConfig,
  environment: Environment,
  runtime: Runtime,
  testPath: string,
): Promise<TestResult>;
```

Un exemple de cette fonction se trouve dans notre [paquet de test jasmine2] par défaut (https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts).


### `testSequencer` [string]

Par défaut : `@jest/test-sequencer`

Cette option vous permet d'utiliser un séquenceur personnalisé au lieu du séquenceur par défaut de Jest. L'option `sort` peut éventuellement retourner une Promesse.

Exemple :

Trier le chemin de test par ordre alphabétique.

```js
// testSequencer.js
const Sequencer = require('@jest/test-sequencer').default;

class CustomSequencer extends Sequencer {
  sort(tests) {
    // Informations sur la structure d'essai
    // https://github.com/facebook/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21
    const copyTests = Array.from(tests);
    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));
  }
}

module.exports = CustomSequencer;
```

Utilisez-le dans votre fichier de configuration Jest comme ceci :

```json
{
  "testSequencer": "path/to/testSequencer.js"
}
```

### `testTimeout` [number]

Par défaut : `5000`

Délai d'attente par défaut d'un test en millisecondes.

### `testURL` [string]

Par défaut : `http://localhost`

Cette option permet de définir l'URL de l'environnement jsdom. Elle se reflète dans des propriétés telles que "location.href".

### `timers` [string]

Par défaut : `real`

Le réglage de cette valeur à `legacy` ou `fake` permet l'utilisation de faux minuteurs pour des fonctions telles que `setTimeout`. Les faux timers sont utiles lorsqu'un morceau de code fixe un long délai d'attente que nous ne voulons pas attendre dans un test.

Si la valeur est `modern`, [`@sinonjs/fake-timers`] (https://github.com/sinonjs/fake-timers) sera utilisé comme implémentation au lieu de l'implémentation de Jest. Ce sera la fausse implémentation par défaut dans Jest 27.

### `transform` [object\<string, pathToTransformer | [pathToTransformer, object]>]

Par défaut : `{"^.+\\.[jt]sx?$": "babel-jest"}`

Une carte qui va des expressions régulières aux chemins des transformateurs. Un transformateur est un module qui fournit une fonction synchrone pour transformer les fichiers sources. Par exemple, si vous voulez pouvoir utiliser une nouvelle fonction de langage dans vos modules ou tests qui ne sont pas encore pris en charge par node, vous pouvez brancher un des nombreux compilateurs qui compilent une version future de JavaScript à une version actuelle. Exemple : voir l'exemple [examples/typescript](https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16) ou le [tutoriel webpack](Webpack.md).

Voici quelques exemples de ces compilateurs :

- [Babel](https://babeljs.io/)
- [TypeScript](http://www.typescriptlang.org/)
- [async-to-gen](http://github.com/leebyron/async-to-gen#jest)
- Pour construire votre propre transformateur, veuillez visiter la section [Custom Transformer] (TutorialReact.md#custom-transformers)

Vous pouvez passer la configuration à un transformateur comme `{filePattern : ['path-to-transformer', {options}]}` Par exemple, pour configurer le babel-jest pour un comportement non par défaut, `{"\\.js$": ['babel-jest', {rootMode: "upward"}]}`

_Note : un transformateur ne fonctionne qu'une fois par fichier, sauf si le fichier a changé. Pendant le développement d'un transformateur, il peut être utile d'exécuter Jest avec "-pas de cache" afin d'effacer fréquemment le cache de Jest (Troubleshooting.md#caching-issues)._

_Note : lors de l'ajout de transformateurs de code supplémentaires, cela écrasera la configuration par défaut et `babel-jest` ne sera plus chargé automatiquement. Si vous voulez l'utiliser pour compiler du JavaScript ou du Typescript, il faut le définir explicitement en ajoutant `{"^.+\\\\.[jt]sx?$" : "babel-jest"}` à la propriété "transform". Voir le [plugin babel-jest](https://github.com/facebook/jest/tree/master/packages/babel-jest#setup)_

### `transformIgnorePatterns` [array\<string>]

Un tableau de chaînes de motifs regexp qui sont comparées à tous les chemins d'accès des fichiers sources avant la transformation. Si le chemin de test correspond à l'un des motifs, il ne sera pas transformé.

Ces chaînes de motifs sont comparées au chemin complet. Utilisez le token `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents.

Exemple : `["<répertoire racine>/bower_components/", "<répertoire racine>/node_modules/"]`.

Il arrive parfois (en particulier dans les projets React Native ou TypeScript) que des modules tiers soient publiés comme non transposés. Comme tous les fichiers à l'intérieur de `node_modules` ne sont pas transformés par défaut, Jest ne comprendra pas le code de ces modules, ce qui entraînera des erreurs de syntaxe. Pour surmonter cela, vous pouvez utiliser `transformIgnorePatterns` pour permettre la transposition de ces modules. Vous trouverez un bon exemple de ce cas d'utilisation dans [React Native Guide] (https://jestjs.io/docs/en/tutorial-react-native#transformignorepatterns-customization).

### `unmockedModulePathPatterns` [array\<string>]

Par défaut : `[]`

Un tableau de l'ensemble de chaînes de regexp qui sont comparées à tous les modules avant que le chargeur de modules ne renvoie automatiquement une maquette. Si le chemin d'un module correspond à l'un des modèles de cette liste, il ne sera pas automatiquement simulé par le chargeur de module.

Cette fonction est utile pour certains modules "utilitaires" couramment utilisés qui servent presque toujours de détails de mise en œuvre (comme les traits de soulignement, les tirets, etc.). Il est généralement préférable de réduire cette liste au minimum et de toujours utiliser des appels explicites à la fonction `jest.mock()`/`jest.unmock()` dans les tests individuels. Il est beaucoup plus facile pour les autres lecteurs du test de raisonner sur l'environnement dans lequel le test sera exécuté.

Il est possible d'outrepasser cette configuration dans les tests individuels en appelant explicitement `jest.mock()` en haut du fichier de test.

### `verbose` [boolean]

Par défaut : `false`

Indique si chaque test individuel doit être signalé pendant l'exécution. Toutes les erreurs seront également indiquées en bas après l'exécution. Notez que si un seul fichier de test est exécuté, il sera par défaut `true`.

### `watchPathIgnorePatterns` [array\<string>]

Par défaut : `[]`

Un tableau de l'ensemble de chaînes de regexp qui sont comparés à tous les chemins d'accès des fichiers sources avant de relancer les tests en mode veille. Si le chemin de fichier correspond à l'un des modèles, il ne déclenchera pas de nouveaux tests lors de la mise à jour.

Ces modèles sont comparés au chemin d'accès complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/node_modules/"]`.

Même si rien n'est spécifié ici, l'observateur ignorera les modifications de tous les fichiers et répertoires cachés, c'est-à-dire les fichiers et les dossiers qui commencent par un point (`.`).

### `watchPlugins` [array\<string | [string, Object]>]

Par défaut : `[]`

Cette option vous permet d'utiliser des plugins de surveillance personnalisés. En savoir plus sur les plugins de surveillance [ici] (watch-plugins).

Voici quelques exemples de plugins watch :

- [`jest-watch-master`](https://github.com/rickhanlonii/jest-watch-master)
- [`jest-watch-select-projects`](https://github.com/rogeliog/jest-watch-select-projects)
- [`jest-watch-suspend`](https://github.com/unional/jest-watch-suspend)
- [`jest-watch-typeahead`](https://github.com/jest-community/jest-watch-typeahead)
- [`jest-watch-yarn-workspaces`](https://github.com/cameronhunter/jest-watch-directories/tree/master/packages/jest-watch-yarn-workspaces)

_Note : Les valeurs de la propriété `watchPlugins` peuvent omettre le préfixe `jest-watch-` du nom du paquet.

### `//` [string]

No default

Cette option permet de faire des commentaires dans `package.json`. Incluez le texte du commentaire comme valeur de cette clé n'importe où dans `package.json`.

Exemple:

```json
{
  "name": "my-project",
  "jest": {
    "//": "Comment goes here",
    "verbose": true
  }
}
```
