
# Les api générales

Dans vos fichiers de test, Jest place chacune de ces méthodes et chacun de ces objets dans l'environnement global. Vous n'avez pas besoin d'exiger ou d'importer quoi que ce soit pour les utiliser. Cependant, si vous préférez des importations explicites, vous pouvez faire `import {describe, expect, test} depuis '@jest/globals'`.

## Methods

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Reference

### `afterAll(fn, timeout)`

Exécute une fonction après que tous les tests de ce fichier ont été effectués. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de continuer.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. Note : Le délai par défaut est de 5 secondes.

Ceci est souvent utile si vous voulez nettoyer un état de configuration global partagé entre les tests.

Par exemple :

```js
const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterAll(() => {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```


Ici, l'`afterAll` garantit que la `cleanUpDatabase` est appelée après tous les tests effectués.

Si `afterAll` est à l'intérieur d'un bloc `describe`, il s'exécute à la fin du bloc describe.

Si vous voulez effectuer un nettoyage après chaque test au lieu de tous les tests, utilisez `afterEach` à la place.

### `afterEach(fn, timeout)`

Exécute une fonction après la fin de chacun des tests de ce dossier. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de continuer.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez nettoyer un état temporaire créé par chaque test.

Par exemple:

```js
const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterEach(() => {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```

Ici, le `afterEach` assure que la `cleanUpDatabase` est appelée après chaque test.

Si `afterEach` est à l'intérieur d'un bloc `describe`, il ne s'exécute qu'après les tests qui sont à l'intérieur de ce bloc de description.

Si vous voulez faire un nettoyage une seule fois, après tous les tests effectués, utilisez plutôt `afterAll`.

### `beforeAll(fn, timeout)`


Exécute une fonction avant que l'un des tests de ce fichier ne soit exécuté. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant d'exécuter les tests.

En option, vous pouvez fournir un `timeout` (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez mettre en place un état global qui sera utilisé par de nombreux tests.

Par exemples :

```js
const globalDatabase = makeGlobalDatabase();

beforeAll(() => {
  // Efface la base de données et ajoute quelques données de test.
  // Jest attendra que cette promesse se concrétise avant de lancer les tests.
  return globalDatabase.clear().then(() => {
    return globalDatabase.insert({testData: 'foo'});
  });
});

// Comme nous n'avons mis en place la base de données qu'une seule fois dans cet exemple, il est important
// que nos tests ne le modifient pas.
test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});
```

Ici, le `beforeAll` garantit que la base de données est mise en place avant que les tests ne soient effectués. Si la configuration était synchrone, vous pourriez le faire sans `beforeAll`. La clé est que Jest attendra une promesse de résolution, donc vous pouvez aussi avoir une configuration asynchrone.

Si `beforeAll` est à l'intérieur d'un bloc `describe`, il s'exécute au début du bloc describe.

Si vous voulez lancer quelque chose avant chaque test au lieu de lancer un test, utilisez plutôt `beforeEach`.

### `beforeEach(fn, timeout)`

Exécute une fonction avant l'exécution de chacun des tests de ce fichier. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de lancer le test.

En option, vous pouvez fournir un ``timeout`` (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez réinitialiser un état global qui sera utilisé par de nombreux tests.

Par exemple :

```js
const globalDatabase = makeGlobalDatabase();

beforeEach(() => {
  // Efface la base de données et ajoute quelques données de test.
  // Jest attendra que cette promesse se concrétise avant de lancer les tests.
  return globalDatabase.clear().then(() => {
    return globalDatabase.insert({testData: 'foo'});
  });
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```

Ici, le `beforeEach` garantit que la base de données est réinitialisée pour chaque test.

Si `beforeEach` est à l'intérieur d'un bloc `describe`, il s'exécute pour chaque test dans le bloc describe.

Si vous n'avez besoin d'exécuter un code de configuration qu'une seule fois, avant tout test, utilisez plutôt `beforeAll`.

### `describe(name, fn)`

`describe(name, fn)` crée un bloc qui regroupe plusieurs tests connexes. Par exemple, si vous avez un objet "ma boisson" qui est censé être délicieux mais pas aigre, vous pouvez le tester avec :

```js
const myBeverage = {
  delicious: true,
  sour: false,
};

describe('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});
```

Ce n'est pas obligatoire - vous pouvez écrire les blocs `test` directement au niveau supérieur. Mais cela peut être pratique si vous préférez que vos tests soient organisés en groupes.

Vous pouvez également imbriquer les blocs ``describe`` si vous disposez d'une hiérarchie de tests :

```js
const binaryStringToNumber = binString => {
  if (!/^[01]+$/.test(binString)) {
    throw new CustomError('Not a binary number.');
  }

  return parseInt(binString, 2);
};

describe('binaryStringToNumber', () => {
  describe('given an invalid binary string', () => {
    test('composed of non-numbers throws CustomError', () => {
      expect(() => binaryStringToNumber('abc')).toThrowError(CustomError);
    });

    test('with extra whitespace throws CustomError', () => {
      expect(() => binaryStringToNumber('  100')).toThrowError(CustomError);
    });
  });

  describe('given a valid binary string', () => {
    test('returns the correct number', () => {
      expect(binaryStringToNumber('100')).toBe(4);
    });
  });
});
```

### `describe.each(table)(name, fn, timeout)`

Utilisez `describe.each` si vous continuez à dupliquer les mêmes suites de tests avec des données différentes. Le fichier `describe.each` vous permet d'écrire la suite de tests une fois et de transmettre les données.

`describe.each` est disponible avec deux API :

#### 1. `describe.each(table)(name, fn, timeout)`

- `table`: `Array` de tableaux avec les arguments qui sont passés dans le `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau 1D de primitives, il sera mappé en interne à un tableau , c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`
- `name`: `String` le titre de la suite de tests.
  - Générer des titres de test uniques en injectant des paramètres de positionnement avec le formatage [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Floating point value.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index of the test case.
    - `%%` - signe de pourcentage unique ('%'). Ceci ne consomme pas d'argument
- `fn`: `Function` la suite de tests à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de fonction.
- En option, vous pouvez fournir un `timeout` (en milliseconds) pour spécifier combien de temps il faut attendre pour chaque ligne avant d'abandonner. _Note : le délai par défaut est de 5 secondes_.

Exemple:

```js
describe.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () => {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () => {
    expect(a + b).not.toBeLessThan(expected);
  });
});
```

#### 2. `` describe.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
  - Première ligne des en-têtes de colonne des noms de variables, séparés par des " | ".
  - Une ou plusieurs lignes de données ultérieures fournies sous forme d'expressions littérales modèles utilisant la syntaxe `${valeur}`.
- `name`: `String` du titre de la suite de tests, utilisez `$variable` pour injecter des données de test dans le titre de la suite à partir des expressions de modèle balisées.
  - Pour injecter des valeurs d'objets imbriquées, vous pouvez fournir un keyPath, c'est-à-dire `$variable.path.to.value`.
- `fn` : `Fonction` la suite de tests à exécuter, c'est la fonction qui recevra l'objet de données de test.
- En option, vous pouvez fournir un `timeout` (en millisecondes) pour spécifier combien de temps il faut attendre pour chaque ligne avant d'abandonner. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
describe.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('$a + $b', ({a, b, expected}) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () => {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () => {
    expect(a + b).not.toBeLessThan(expected);
  });
});
```

### `describe.only(name, fn)`

Également sous l'alias: `fdescribe(name, fn)`

Vous pouvez utiliser `describe.only` si vous ne voulez exécuter qu'un seul bloc de description :

```js
describe.only('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe('my other beverage', () => {
  // ... seront ignorées
});
```

### `describe.only.each(table)(name, fn)`

Également sous l'alias: `fdescribe.each(table)(name, fn)` and `` fdescribe.each`table`(name, fn) ``

Utilisez `describe.only.each` si vous voulez seulement exécuter des suites de tests spécifiques de tests pilotés par les données.

Le programme `describe.only.each` est disponible avec deux API :

#### `describe.only.each(table)(name, fn)`

```js
describe.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` describe.only.each`table`(name, fn) ``

```js
describe.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  test('passes', () => {
    expect(a + b).toBe(expected);
  });
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `describe.skip(name, fn)`

Également sous l'alias: `xdescribe(name, fn)`

Vous pouvez utiliser `describe.skip` si vous ne voulez pas exécuter un bloc de description particulier :

```js
describe('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe.skip('my other beverage', () => {
  // ... seront ignorées
});
```

L'utilisation de `describe.skip` est souvent une alternative plus propre que de commenter temporairement une partie des tests.

### `describe.skip.each(table)(name, fn)`

Also under the aliases: `xdescribe.each(table)(name, fn)` et `` xdescribe.each`table`(name, fn) ``

Utilisez `describe.skip.each` si vous voulez arrêter d'exécuter une suite de tests basés sur des données.

`describe.skip.each` est disponible avec deux API :

#### `describe.skip.each(table)(name, fn)`

```js
describe.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected); // ne sera pas gérée
  });
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` describe.skip.each`table`(name, fn) ``

```js
describe.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  test('will not be ran', () => {
    expect(a + b).toBe(expected); // ne sera pas gérée
  });
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test(name, fn, timeout)`

Également sous l'alias: `it(name, fn, timeout)`

Tout ce dont vous avez besoin dans un fichier de test est la méthode `test` qui exécute un test. Par exemple, disons qu'il y a une fonction `inchesOfRain()` qui devrait être à zéro. Tout votre test pourrait l'être :

```js
test('did not rain', () => {
  expect(inchesOfRain()).toBe(0);
});
```

Le premier argument est le nom du test ; le deuxième argument est une fonction qui contient les attentes à tester. Le troisième argument (facultatif) est le "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

> Note : Si une **promesse est retournée** de `test`, Jest attendra la résolution de la promesse avant de laisser le test se terminer. Jest attendra également si vous **fournissez un argument à la fonction de test**, généralement appelé "done". Cela peut être pratique lorsque vous voulez tester les rappels. Voir comment tester le code async [ici](TestingAsyncCode.md#callbacks).

Par exemple, disons que `fetchBeverageList()` renvoie une promesse qui est supposée se résoudre à une liste qui contient du `citron`. Vous pouvez tester cela avec :

```js
test('has lemon in it', () => {
  return fetchBeverageList().then(list => {
    expect(list).toContain('lemon');
  });
});
```

Même si l'appel au `test` revient tout de suite, le test n'est pas terminé tant que la promesse n'est pas résolue.

### `test.concurrent(name, fn, timeout)`

Également sous l'alias: `it.concurrent(name, fn, timeout)`

Utilisez `test.concurrent` si vous voulez que le test s'exécute en même temps.

> Note : `test.concurrent` est considéré comme expérimental - voir [ici])https://github.com/facebook/jest/labels/Area%3A%20Concurrent) pour plus de détails sur les fonctionnalités manquantes et autres problèmes

Le premier argument est le nom du test ; le second argument est une fonction asynchrone qui contient les attentes à tester. Le troisième argument (facultatif) est le "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. Note : Le délai par défaut est de 5 secondes.

```
test.concurrent('addition of 2 numbers', async () => {
  expect(5 + 3).toBe(8);
});

test.concurrent('subtraction 2 numbers', async () => {
  expect(5 - 3).toBe(2);
});
```

> Note : Utilisez `maxConcurrency` dans la configuration pour empêcher Jest d'exécuter plus que la quantité spécifiée de tests en même temps

### `test.concurrent.each(table)(name, fn, timeout)`

Également sous l'alias: `it.concurrent.each(table)(name, fn, timeout)`

Utilisez `test.concurrent.each` si vous continuez à dupliquer le même test avec des données différentes. `test.each` vous permet d'écrire le test une fois et de passer les données, les tests sont tous exécutés de manière asynchrone.

`test.concurrent.each` est disponible avec deux API :

#### 1. `test.concurrent.each(table)(name, fn, timeout)`

- `table`: Un `Array` de tableaux avec les arguments qui sont passés dans le test `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau de 1D de primitives, il sera mis en correspondance avec un tableau interne, c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`;
- `name`: `String` le titre bloc du test.
  -   - Générer des titres de test uniques en injectant des paramètres de positionnement avec [ le formatage `printf`](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Valeur en virgule flottante.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index du cas type.
    - `%%` - le signe de pourcentage unique ("%"). Cela ne consomme pas d'argument.
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de la fonction, **cela devra être une fonction asynchrone**.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.
Example:

```js
test.concurrent.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### 2. `` test.concurrent.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
  - La première ligne des en-têtes de colonne du nom de la variable, spéraré avec un `|`.
  - Une ou plusieurs lignes ultérieures de données fournies comme modèles d'expressions littérales en utilisant la syntaxe `${valeur}`.
- `name`: En utilisant `String` comme titre du test , utilisez `$variable` pour injecter des données de test dans le titre à partir des expressions de modèle balisées
  - Pour injecter des valeurs d'objets imbriqués, vous pouvez fournir un keyPath, c'est-à-dire `$variable.path.to.value`
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra l'objet de données de test, **cela devra être une fonction asynchrone**.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.concurrent.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

### `test.concurrent.only.each(table)(name, fn)`

Également sous l'alias: `it.concurrent.only.each(table)(name, fn)`

Utilisez `test.concurrent.only.each` si vous voulez seulement exécuter des tests spécifiques avec des données de test différentes en même temps.

`test.concurrent.only.each` est disponible avec deux API:

#### `test.concurrent.only.each(table)(name, fn)`

```js
test.concurrent.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', async (a, b, expected) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.only.each`table`(name, fn) ``

```js
test.concurrent.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', async ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.concurrent.skip.each(table)(name, fn)`

Également sous l'alias: `it.concurrent.skip.each(table)(name, fn)`

Utilisez `test.concurrent.skip.each` si vous voulez arrêter d'exécuter une collection de tests asynchrones basés sur des données.

`test.concurrent.skip.each` est disponible avec deux APIs:

#### `test.concurrent.skip.each(table)(name, fn)`

```js
test.concurrent.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', async (a, b, expected) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.concurrent.skip.each`table`(name, fn) ``

```js
test.concurrent.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', async ({a, b, expected}) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.each(table)(name, fn, timeout)`

Également sous l'alias: `it.each(table)(name, fn)` et `` it.each`table`(name, fn) ``

Utilisez `test.each` si vous continuez à dupliquer le même test avec des données différentes. Le `test.each` vous permet d'écrire le test une fois et de transmettre les données.

`test.each` est disponible avec deux APIs:

#### 1. `test.each(table)(name, fn, timeout)`

- `table`: Un `Array` de tableaux avec les arguments qui sont passés dans le test `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau de 1D de primitives, il sera mis en correspondance avec un tableau interne, c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`;
- `name`: `String` le titre bloc du test.
  - Générer des titres de test uniques en injectant des paramètres de positionnement avec [ le formatage `printf`](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Valeur en virgule flottante.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index du cas type.
    - `%%` - le signe de pourcentage unique ("%"). Cela ne consomme pas d'argument.
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de la fonction.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### 2. `` test.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
- Première ligne des en-têtes de colonne des noms de variables, séparés par des " | ".
- Une ou plusieurs lignes de données ultérieures fournies sous forme d'expressions littérales modèles utilisant la syntaxe `${valeur}`.
- `name`: `String` le titre du test, utilisez `$variable`pour injecter des données de test dans le titre du test à partir des expressions de modèle balisées
- Pour injecter des valeurs d'objet imbriquées, vous pouvez fournir un keyPath, c'est-à-dire . `$variable.path.to.value`
- `fn`: `Function` le test à effectuer, c'est la fonction qui recevra l'objet de données de test.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

### `test.only(name, fn, timeout)`

Également sous l'alias: `it.only(name, fn, timeout)`, et `fit(name, fn, timeout)`

Lorsque vous déboguez un gros fichier de test, vous ne voudrez souvent exécuter qu'un sous-ensemble de tests. Vous pouvez utiliser `.only` pour spécifier quels sont les seuls tests que vous voulez exécuter dans ce fichier de test.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier combien de temps il faut attendre avant d'abandonner. Note : Le délai par défaut est de 5 secondes.

Par exemple, disons que vous avez fait ces tests :

Traduit avec www.DeepL.com/Translator (version gratuite)

```js
test.only('it is raining', () => {
  expect(inchesOfRain()).toBeGreaterThan(0);
});

test('it is not snowing', () => {
  expect(inchesOfSnow()).toBe(0);
});
```

Seul le test "it is rainignt" sera exécuté dans ce fichier de test, puisqu'il est exécuté avec `test.only`.

Habituellement, vous ne vérifiez pas le code en utilisant `test.only` dans le contrôle des sources - vous l'utilisez pour le débogage, et le supprimez une fois que vous avez corrigé les tests cassés.

### `test.only.each(table)(name, fn)`

Également sous l'alias: `it.only.each(table)(name, fn)`, `fit.each(table)(name, fn)`, `` it.only.each`table`(name, fn) `` et `` fit.each`table`(name, fn) ``

Utilisez `test.only.each` si vous voulez seulement effectuer des tests spécifiques avec des données de test différentes.

`test.only.each` est disponible avec deux APIs:

#### `test.only.each(table)(name, fn)`

```js
test.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.only.each`table`(name, fn) ``

```js
test.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.skip(name, fn)`

Également sous l'alias: `it.skip(name, fn)`, `xit(name, fn)`, et `xtest(name, fn)`

Lorsque vous maintenez une base de données importante, vous pouvez parfois trouver un test qui est temporairement interrompu pour une raison quelconque. Si vous voulez sauter l'exécution de ce test, mais que vous ne voulez pas supprimer ce code, vous pouvez utiliser `test.skip` pour spécifier certains tests à sauter.

Par exemple, disons que vous avez ces tests :

```js
test('it is raining', () => {
  expect(inchesOfRain()).toBeGreaterThan(0);
});

test.skip('it is not snowing', () => {
  expect(inchesOfSnow()).toBe(0);
});
```

Seul le test "it is raining" sera effectué, puisque l'autre test est effectué avec `test.skip`.

Vous pouvez commenter le test, mais il est souvent un peu plus agréable d'utiliser `test.skip` car il maintient l'indentation et la mise en évidence syntaxique.

### `test.skip.each(table)(name, fn)`

Also under the aliases: `it.skip.each(table)(name, fn)`, `xit.each(table)(name, fn)`, `xtest.each(table)(name, fn)`, `` it.skip.each`table`(name, fn) ``, `` xit.each`table`(name, fn) `` and `` xtest.each`table`(name, fn) ``

Utilisez `test.skip.each` si vous voulez arrêter d'effectuer une collecte de données.

`test.skip.each` est disponible avec deux APIs:

#### `test.skip.each(table)(name, fn)`

```js
test.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.skip.each`table`(name, fn) ``

```js
test.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.todo(name)`

Également sous l'alias: `it.todo(name)`

Utilisez `test.todo` lorsque vous prévoyez de passer des tests. Ces tests seront mis en évidence dans le résumé à la fin afin que vous sachiez combien de tests il vous reste à faire.

_Note_ : Si vous fournissez une fonction de rappel de test, alors le `test.todo` lancera une erreur. Si vous avez déjà implémenté le test et qu'il est cassé et que vous ne voulez pas qu'il s'exécute, alors utilisez `test.skip` à la place.

Traduit avec www.DeepL.com/Translator (version gratuite)

#### API

- `name`: `String` le titre du plan d'essai.

Exemple:

```js
const add = (a, b) => a + b;

test.todo('add should be associative');
```


# Expect

Lorsque vous passez des tests, vous devez souvent vérifier que les valeurs répondent à certaines conditions. `expect` vous donne accès à un certain nombre de "matchers" qui vous permettent de valider différentes choses.

Pour obtenir d'autres "matchers" Jest, gérés par la communauté Jest, consultez [`jest-extended`] (https://github.com/jest-community/jest-extended).

## Les méthodes

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Les références

### `expect(value)`

La fonction `expect` est utilisée chaque fois que vous voulez tester une valeur. Il est rare que vous appeliez la fonction `expect` par elle-même. Au lieu de cela, vous utiliserez `expect` avec une fonction "matcher" pour affirmer quelque chose sur la valeur.

Il est plus facile de comprendre cela avec un exemple. Disons que vous avez une méthode `bestLaCroixFlavor()` qui est censée retourner la chaîne `'grapefruit'`. Voici comment vous pourriez tester cela :


```js
test('the best flavor is grapefruit', () => {
  expect(bestLaCroixFlavor()).toBe('grapefruit');
});
```
Dans ce cas, `toBe` est une fonction d'appariement. Il existe un grand nombre de fonctions de matcher différentes, documentée ci-dessous, pour vous aider à tester différentes choses.

L'argument `expect` doit être la valeur que votre code produit, et tout argument  au matcher doit être la valeur correcte. Si vous les mélangez, vos tests fonctionneront toujours, mais les messages d'erreur des tests d'échoués seront étranges.

### `expect.extend(matchers)`

Vous pouvez utiliser `expect.extend` pour ajouter vos propres correspondants à Jest. Par exemple, disons que vous testez une bibliothèque d'utilitaires de nombres et que vous affirmez fréquemment que des nombres apparaissent dans des plages particulières d'autres nombres. Vous pourriez résumer cela dans un appariement `toBeWithinRange` :

```js
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

test('numeric ranges', () => {
  expect(100).toBeWithinRange(90, 110);
  expect(101).not.toBeWithinRange(0, 100);
  expect({apples: 6, bananas: 3}).toEqual({
    apples: expect.toBeWithinRange(1, 10),
    bananas: expect.not.toBeWithinRange(11, 20),
  });
});
```

_Note : En TypeScript, lorsque vous utilisez `@types/jest` par exemple, vous pouvez déclarer le nouveau comparateur `toBeWithinRange` comme ceci :

```ts
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeWithinRange(a: number, b: number): R;
    }
  }
}
```

#### Les Matchers Async

`expect.extend` prend également en charge les matchers asynchrones. Les matchers asynchrones renvoient une promesse, vous devrez donc attendre la valeur renvoyée. Utilisons un exemple de matcher pour illustrer leur utilisation. Nous allons implémenter un appariement appelé `toBeDivisibleByExternalValue`, où le nombre divisible sera tiré d'une source externe.

```js
expect.extend({
  async toBeDivisibleByExternalValue(received) {
    const externalValue = await getExternalValueFromRemoteSource();
    const pass = received % externalValue == 0;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be divisible by ${externalValue}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be divisible by ${externalValue}`,
        pass: false,
      };
    }
  },
});

test('is divisible by external value', async () => {
  await expect(100).toBeDivisibleByExternalValue();
  await expect(101).not.toBeDivisibleByExternalValue();
});
```

#### Les API personnalisé Matchers


Les correspondants doivent rendre un objet (ou une promesse d'objet) avec deux clés. La touche `pass` indique s'il y a eu correspondance ou non, et la touche `message` fournit une fonction sans argument qui renvoie un message d'erreur en cas d'échec. Ainsi, lorsque `pass` est faux, `message` devrait renvoyer le message d'erreur pour le cas où `expect(x).yourMatcher()` échouerait. Et quand "pass" est vrai, "message" doit renvoyer le message d'erreur pour le cas où `expect(x).not.yourMatcher()` échoue.

Les correspondants sont appelés avec l'argument passé à `expect(x)` suivi par les arguments passés à `.yourMatcher(y, z)` :

```js
expect.extend({
  yourMatcher(x, y, z) {
    return {
      pass: true,
      message: () => '',
    };
  },
});
```

Ces fonctions et propriétés d'aide peuvent être trouvées sur `this` à l'intérieur d'un Custom Matcher :

#### `this.isNot`

Un booléen pour vous faire savoir que ce "matcher" a été appelé avec le modificateur négatif `.not` vous permettant d'afficher un indice de matcher clair et correct (voir l'exemple de code).

#### `this.promise`

Une chaîne vous permettant d'afficher un indice de correspondance clair et correct :

- `'rejects'` si le matcher a été appelé avec le modificateur `.rejects` de la promesse
- `'resolves'` si le matcher a été appelé avec la promesse `.resolves` modificateur
- `''` si le matcher n'a pas été appelé avec un modificateur de promesse

#### `this.equals(a, b)`

Il s'agit d'une fonction d'égalité profonde qui retournera `true` si deux objets ont les mêmes valeurs (de manière récursive).

#### `this.expand`

Un booléen pour vous faire savoir que ce matcher a été appelé avec une option `expand`. Lorsque Jest est appelé avec l'option `--expand`, `this.expand` peut être utilisé pour déterminer si Jest doit afficher les différences et erreurs complètes.

#### `this.utils`

Il existe un certain nombre d'outils utiles exposés sur `this.utils`, qui consistent principalement en des exportations de [`jest-matcher-utils`] (https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils).

Les plus utiles sont `matcherHint`, `printExpected` et `printReceived` pour formater les messages d'erreur. Par exemple, jetez un oeil à l'implémentation de l'appariement `toBe` :


```js
const diff = require('jest-diff');
expect.extend({
  toBe(received, expected) {
    const options = {
      comment: 'Object.is equality',
      isNot: this.isNot,
      promise: this.promise,
    };

    const pass = Object.is(received, expected);

    const message = pass
      ? () =>
          this.utils.matcherHint('toBe', undefined, undefined, options) +
          '\n\n' +
          `Expected: not ${this.utils.printExpected(expected)}\n` +
          `Received: ${this.utils.printReceived(received)}`
      : () => {
          const diffString = diff(expected, received, {
            expand: this.expand,
          });
          return (
            this.utils.matcherHint('toBe', undefined, undefined, options) +
            '\n\n' +
            (diffString && diffString.includes('- Expect')
              ? `Difference:\n\n${diffString}`
              : `Expected: ${this.utils.printExpected(expected)}\n` +
                `Received: ${this.utils.printReceived(received)}`)
          );
        };

    return {actual: received, message, pass};
  },
});
```

Cela permettra d'avoir quelque chose comme ceci :

```bash
  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      "banana"
    Received:
      "apple"
```

Lorsqu'une assertion échoue, le message d'erreur doit donner autant de signal que nécessaire à l'utilisateur afin qu'il puisse résoudre son problème rapidement. Vous devez élaborer un message d'échec précis pour vous assurer que les utilisateurs de vos assertions personnalisées ont une bonne expérience de développement.

#### Personnaliser les matchers snapshot

Pour utiliser le test de l'instantané dans votre Custom Matcher, vous pouvez importer un `jest-snapshot` et l'utiliser dans votre Matcher.

Voici un snapshot qui coupe une chaîne à stocker pour une longueur donnée, `.toMatchTrimmedSnapshot(length)` :

```js
const {toMatchSnapshot} = require('jest-snapshot');

expect.extend({
  toMatchTrimmedSnapshot(received, length) {
    return toMatchSnapshot.call(
      this,
      received.substring(0, length),
      'toMatchTrimmedSnapshot',
    );
  },
});

it('stores only 10 characters', () => {
  expect('extra long string oh my gerd').toMatchTrimmedSnapshot(10);
});

/*
Stored snapshot will look like:

exports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `"extra long"`;
*/
```

Il est également possible de créer des correspondances personnalisées pour les instantanés en ligne, les instantanés seront correctement ajoutés aux correspondances personnalisées. Cependant, les instantanés en ligne essaieront toujours de s'ajouter au premier argument ou au second lorsque le premier argument est le comparateur de propriétés, il n'est donc pas possible d'accepter des arguments personnalisés dans les comparateurs personnalisés.

```js
const {toMatchInlineSnapshot} = require('jest-snapshot');

expect.extend({
  toMatchTrimmedInlineSnapshot(received) {
    return toMatchInlineSnapshot.call(this, received.substring(0, 10));
  },
});

it('stores only 10 characters', () => {
  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot();
  /*
  L'instantané sera ajouté en ligne comme
  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(
    "extra long"
  ) ;
  */
});
```

### `expect.anything()`

Le terme `expect.anything()` correspond à tout sauf `null` ou `undefined`. Vous pouvez l'utiliser dans `toEqual` ou `toBeCalledWith` au lieu d'une valeur littérale. Par exemple, si vous voulez vérifier qu'une fonction fictive est appelée avec un argument non nul :

```js
test('map calls its argument with a non-null argument', () => {
  const mock = jest.fn();
  [1].map(x => mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
```

### `expect.any(constructor)`

`expect.any(constructor)` correspond à tout ce qui a été créé avec le constructeur donné. Vous pouvez l'utiliser dans `toEqual` ou `toBeCalledWith` au lieu d'une valeur littérale. Par exemple, si vous voulez vérifier qu'une fonction fictive est appelée avec un nombre :

```js
function randocall(fn) {
  return fn(Math.floor(Math.random() * 6 + 1));
}

test('randocall calls its callback with a number', () => {
  const mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(Number));
});
```

### `expect.arrayContaining(array)`


Le fichier `expect.arrayContaining(array)` correspond à un tableau reçu qui contient tous les éléments du tableau attendu. C'est-à-dire que le tableau attendu est un **sous-ensemble** du tableau reçu. Par conséquent, il correspond à un tableau reçu qui contient des éléments qui ne sont pas **not** dans le tableau attendu.

Vous pouvez l'utiliser à la place d'une valeur littérale :

- dans `toEqual` ou `toBeCalledWith`.
- pour correspondre à une propriété dans `objectContaining` ou `toMatchObject`.

```js
describe('arrayContaining', () => {
  const expected = ['Alice', 'Bob'];
  it('matches even if received contains additional elements', () => {
    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));
  });
  it('does not match if received does not contain expected elements', () => {
    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));
  });
});
```

```js
describe('Beware of a misunderstanding! A sequence of dice rolls', () => {
  const expected = [1, 2, 3, 4, 5, 6];
  it('matches even with an unexpected number 7', () => {
    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it('does not match without an expected number 2', () => {
    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
```

### `expect.assertions(number)`

`expect.assertions(number)` verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.

For example, let's say that we have a function `doAsync` that receives two callbacks `callback1` and `callback2`, it will asynchronously call both of them in an unknown order. We can test this with:

Le paramètre `expect.assertions(number)` vérifie qu'un certain nombre d'assertions sont appelées pendant un test. Cela est souvent utile lors de tests de code asynchrone, afin de s'assurer que les assertions d'un rappel ont bien été appelées.

Par exemple, disons que nous avons une fonction `doAsync` qui reçoit deux callbacks `callback1` et `callback2`, elle les appellera tous les deux de manière asynchrone dans un ordre inconnu. Nous pouvons tester cela avec :

```js
test('doAsync calls both callbacks', () => {
  expect.assertions(2);
  function callback1(data) {
    expect(data).toBeTruthy();
  }
  function callback2(data) {
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
```

L'appel `expect.assertions(2)` assure que les deux rappels sont effectivement appelés.

### `expect.hasAssertions()`

La fonction `expect.hasAssertions()` vérifie qu'au moins une assertion est appelée pendant un test. Ceci est souvent utile lors de tests de code asynchrone, afin de s'assurer que les assertions d'un callback ont bien été appelées.


Par exemple, disons que nous avons quelques fonctions qui traitent toutes de l'état. `prepareState` appelle un callback avec un objet d'état, `validateState` s'exécute sur cet objet d'état, et `waitOnState` renvoie une promesse qui attend que tous les callbacks `prepareState` soient terminés. Nous pouvons tester cela avec :

```js
test('prepareState prepares a valid state', () => {
  expect.hasAssertions();
  prepareState(state => {
    expect(validateState(state)).toBeTruthy();
  });
  return waitOnState();
});
```

L'appel `expect.hasAssertions()` assure que le rappel `prepareState` est effectivement appelé.

### `expect.not.arrayContaining(array)`

`Expect.not.arrayContaining(array)` correspond à un tableau reçu qui ne contient pas tous les éléments du tableau attendu. C'est-à-dire que le tableau attendu **n'est pas un sous-ensemble** du tableau reçu.

C'est l'inverse de `expect.arrayContaining`.

```js
describe('not.arrayContaining', () => {
  const expected = ['Samantha'];

  it('matches if the actual array does not contain the expected elements', () => {
    expect(['Alice', 'Bob', 'Eve']).toEqual(
      expect.not.arrayContaining(expected),
    );
  });
});
```

### `expect.not.objectContaining(object)`

`expect.not.objectContaining(object)` correspond à tout objet reçu qui ne correspond pas récursivement aux propriétés attendues. C'est-à-dire que l'objet attendu **n'est pas un sous-ensemble** de l'objet reçu. Par conséquent, il correspond à un objet reçu qui contient des propriétés qui ne sont **pas** dans l'objet attendu.

C'est l'inverse de `expect.objectContaining`.

```js
describe('not.objectContaining', () => {
  const expected = {foo: 'bar'};

  it('matches if the actual object does not contain expected key: value pairs', () => {
    expect({bar: 'baz'}).toEqual(expect.not.objectContaining(expected));
  });
});
```

### `expect.not.stringContaining(string)`

`expect.not.stringContaining(string)` `expect.not.stringContaining(string)` vérifie la valeur reçu si ce n'est pas une chaîne de caractères ou si c'est une chaîne qui ne contient pas la chaîne attendue exacte.

C'est l'inverse de `expect.stringContaining`.
```js
describe('not.stringContaining', () => {
  const expected = 'Hello world!';

  it('matches if the received value does not contain the expected substring', () => {
    expect('How are you?').toEqual(expect.not.stringContaining(expected));
  });
});
```

### `expect.not.stringMatching(string | regexp)`

`expect.not.stringMatching(string | regexp)` correspond à la valeur reçue si ce n'est pas une chaîne ou si c'est une chaîne qui ne correspond pas à la chaîne ou à l'expression régulière attendue.

C'est l'inverse de `expect.stringMatching`.

```js
describe('not.stringMatching', () => {
  const expected = /Hello world!/;

  it('matches if the received value does not match the expected regex', () => {
    expect('How are you?').toEqual(expect.not.stringMatching(expected));
  });
});
```

### `expect.objectContaining(object)`

`expect.objectContaining(object)` correspond à tout objet reçu qui correspond récursivement aux propriétés attendues. Autrement dit, l'objet attendu est un **sous-ensemble** de l'objet reçu. Par conséquent, il correspond à un objet reçu qui contient des propriétés qui **sont présentes** dans l'objet attendu.

Au lieu de valeurs de propriétés littérales dans l'objet attendu, vous pouvez utiliser des appariements, `expect.anything()`, et ainsi de suite.

Par exemple, disons que nous nous attendons à ce qu'une fonction `onPress` soit appelée avec un objet `Event`, et tout ce que nous devons vérifier est que l'événement a des propriétés `event.x` et `event.y`. Nous pouvons faire cela avec :

```js
test('onPress gets called with the right thing', () => {
  const onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      x: expect.any(Number),
      y: expect.any(Number),
    }),
  );
});
```

### `expect.stringContaining(string)`

`expect.stringContaining(string)` correspond à la valeur reçue s'il s'agit d'une chaîne qui contient la chaîne exacte attendue.

### `expect.stringMatching(string | regexp)`

Vous pouvez l'utiliser à la place d'une valeur littérale :

- dans `toEqual` ou `toBeCalledWith`.
- pour correspondre à un élément dans `arrayContaining`.
- pour correspondre à une propriété dans `objectContaining` ou `toMatchObject`.

Cet exemple montre également comment vous pouvez imbriquer plusieurs correspondants asymétriques, avec `expect.stringMatching` dans le `expect.arrayContaining`".

```js
describe('stringMatching in arrayContaining', () => {
  const expected = [
    expect.stringMatching(/^Alic/),
    expect.stringMatching(/^[BR]ob/),
  ];
  it('matches even if received contains additional elements', () => {
    expect(['Alicia', 'Roberto', 'Evelina']).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it('does not match if received does not contain expected elements', () => {
    expect(['Roberto', 'Evelina']).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
```

### `expect.addSnapshotSerializer(serializer)`

Vous pouvez appeler `expect.addSnapshotSerializer` pour ajouter un module qui formate des structures de données spécifiques à l'application.

Pour un fichier de test individuel, un module ajouté précède tous les modules de la configuration de `snapshotSerializers`, qui précèdent les sérialiseurs snapshot par défaut pour les types JavaScript intégrés et pour les éléments React. Le dernier module ajouté est le premier module testé.

```js
import serializer from 'my-serializer-module';
expect.addSnapshotSerializer(serializer);

// affecte les assertions expect(value).toMatchSnapshot() dans le fichier de test
```

Si vous ajoutez un snapshot sérialiser dans les fichiers de test individuels au lieu de l'ajouter à la configuration de `snapshotSerializers` :

- Vous rendez la dépendance explicite au lieu de l'implicite.
- Vous évitez les limites de configuration qui pourraient vous faire éjecter de [create-react-app](https://github.com/facebookincubator/create-react-app).

Voir [configuring Jest](Configuration.md#snapshotserializers-arraystring) pour plus d'informations.

### `.not`

Si vous savez comment tester quelque chose, ".not" vous permet de tester son contraire. Par exemple, ce code teste que la meilleure saveur de La Croix n'est pas la noix de coco :

```js
test('the best flavor is not coconut', () => {
  expect(bestLaCroixFlavor()).not.toBe('coconut');
});
```

### `.resolves`

Utilisez les `resolves` pour ouvrir la valeur d'une promesse tenue afin d'enchaîner tout autre partenaire. Si la promesse est rejetée, l'affirmation échoue.

Par exemple, ce code teste que la promesse est résolue et que la valeur résultante est `'lemon'` :

```js
test('resolves to lemon', () => {
  // s'assurer d'ajouter une déclaration de retour
  return expect(Promise.resolve('lemon')).resolves.toBe('lemon');
});
```

Notez que, puisque vous testez encore les promesses, le test est toujours asynchrone. Par conséquent, vous devrez [dire à Jest d'attendre](TestingAsyncCode.md#promises) en renvoyant l'affirmation non emballée.

Alternativement, vous pouvez utiliser `async/await` en combinaison avec `.resolves` :

```js
test('resolves to lemon', async () => {
  await expect(Promise.resolve('lemon')).resolves.toBe('lemon');
  await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');
});
```

### `.rejects`

Utilisez `.rejects` pour ouvrir la raison du rejects d'une promesse afin que tout autre correspondant puisse être enchaîné. Si la promesse est tenue, l'affirmation échoue.

Par exemple, ce code teste que la promesse est rejetée avec la raison `'octopus'` :

```js
test('rejects to octopus', () => {
  // s'assurer d'ajouter une déclaration de retour
  return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(
    'octopus',
  );
});
```

Notez que, puisque vous testez encore les promesses, le test est toujours asynchrone. Par conséquent, vous devrez [dire à Jest d'attendre](TestingAsyncCode.md#promises) en renvoyant l'affirmation non emballée.

Vous pouvez aussi utiliser `async/await` en combinaison avec `.rejects`.

```js
test('rejects to octopus', async () => {
  await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');
});
```

### `.toBe(value)`

Utilisez `.toBe` pour comparer des valeurs primitives ou pour vérifier l'identité référentielle des instances d'un objet. Il appelle `Object.is` pour comparer des valeurs, ce qui est encore mieux pour les tests que l'opérateur d'égalité stricte `===`.

Par exemple, ce code va valider certaines propriétés de l'objet `can` :

```js
const can = {
  name: 'pamplemousse',
  ounces: 12,
};

describe('the can', () => {
  test('has 12 ounces', () => {
    expect(can.ounces).toBe(12);
  });

  test('has a sophisticated name', () => {
    expect(can.name).toBe('pamplemousse');
  });
});
```

N'utilisez pas de ".toBe" avec des nombres à virgule flottante. Par exemple, en raison de l'arrondissement, en JavaScript, `0.2 + 0.1` n'est pas strictement égal à `0.3`. Si vous avez des nombres à virgule flottante, essayez plutôt `.toBeCloseTo`.

Bien que l'appariement `.toBe` vérifie** l'identité référentielle, il **rapporte** une comparaison approfondie des valeurs si l'assertion échoue. Si les différences entre les propriétés ne vous aident pas à comprendre pourquoi un test échoue, en particulier si le rapport est important, alors vous pouvez déplacer la comparaison dans la fonction `expect`. Par exemple, pour affirmer si des éléments sont la même instance ou non :

- réécrivez `expect(received).toBe(expected)` comme `expect(Object.is(received, expected)).toBe(true)`.
- réécrire `expect(received).not.toBe(expected)` comme `expect(Object.is(received, expected)).toBe(false)`.

### `.toHaveBeenCalled()`

Également sous l'alias : `.toBeCalled()`.

Utilisez `toHaveBeenCalled` pour vous assurer qu'une fonction fictive a été appelée.

Par exemple, disons que vous avez une fonction `drinkAll(drink, flavour)` qui prend une fonction `drink` et l'applique à toutes les boissons disponibles. Vous pouvez vérifier que `drink` est appelé pour `"lemon"`, mais pas pour `"octopus"`, parce que le goût `"octopus"` est vraiment bizarre et pourquoi quelque chose aurait un goût de poulpe ? Vous pouvez faire cela avec cette suite de tests :

```js
function drinkAll(callback, flavour) {
  if (flavour !== 'octopus') {
    callback(flavour);
  }
}

describe('drinkAll', () => {
  test('drinks something lemon-flavoured', () => {
    const drink = jest.fn();
    drinkAll(drink, 'lemon');
    expect(drink).toHaveBeenCalled();
  });

  test('does not drink something octopus-flavoured', () => {
    const drink = jest.fn();
    drinkAll(drink, 'octopus');
    expect(drink).not.toHaveBeenCalled();
  });
});
```

### `.toHaveBeenCalledTimes(number)`

Également sous l'alias : `.toBeCalledTimes(number)`

Utilisez "toHaveBeenCalledTimes" pour vous assurer qu'une fonction fictive a été appelée le nombre exact de fois.

Par exemple, disons que vous avez une fonction `drinkEach(drink, Array<flavor>)` qui prend une fonction `drink` et l'applique à un tableau de boissons passées. Vous pourriez vouloir vérifier que la fonction "drink" a été appelée le nombre exact de fois. Vous pouvez le faire avec cette suite de tests :

```js
test('drinkEach drinks each drink', () => {
  const drink = jest.fn();
  drinkEach(drink, ['lemon', 'octopus']);
  expect(drink).toHaveBeenCalledTimes(2);
});
```

### `.toHaveBeenCalledWith(arg1, arg2, ...)`

Également sous l'alias : `.toBeCalledWith()`

Utilisez `.toHaveBeenCalledWith` pour vous assurer qu'une fonction fictive a été appelée avec des arguments spécifiques.

Par exemple, disons que vous pouvez enregistrer une boisson avec une fonction `register`, et que `applyToAll(f)` devrait appliquer la fonction `f` à toutes les boissons enregistrées. Pour être sûr que cela fonctionne, vous pouvez écrire :

```js
test('registration applies correctly to orange La Croix', () => {
  const beverage = new LaCroix('orange');
  register(beverage);
  const f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
```

### `.toHaveBeenLastCalledWith(arg1, arg2, ...)`

Également sous l'alias : `.lastCalledWith(arg1, arg2, ...)`

Si vous avez une fonction fictive, vous pouvez utiliser `.toHaveBeenLastCalledWith` pour tester les arguments avec lesquels elle a été appelée en dernier. Par exemple, disons que vous avez une fonction `applyToAllFlavors(f)` qui applique `f` à un ensemble de saveurs, et que vous voulez vous assurer que lorsque vous l'appelez, la dernière saveur sur laquelle elle fonctionne est `'mango`. Vous pouvez écrire :

```js
test('applying to all flavors does mango last', () => {
  const drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith('mango');
});
```

### `.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)`

Également sous l'alias : `.nthCalledWith(nthCall, arg1, arg2, ...)`

Si vous avez une fonction fictive, vous pouvez utiliser `.toHaveBeenNthCalledWith` pour tester les arguments avec lesquels elle a été appelée. Par exemple, supposons que vous ayez une fonction `drinkEach(drink, Array<flavor>)` qui applique `f` à un ensemble de saveurs, et que vous vouliez vous assurer que lorsque vous l'appelez, la première saveur sur laquelle elle fonctionne est ``lemon`` et la seconde est 'octopus'. Vous pouvez écrire :

```js
test('drinkEach drinks each drink', () => {
  const drink = jest.fn();
  drinkEach(drink, ['lemon', 'octopus']);
  expect(drink).toHaveBeenNthCalledWith(1, 'lemon');
  expect(drink).toHaveBeenNthCalledWith(2, 'octopus');
});
```

Note : le nième argument doit être un nombre entier positif à partir de 1.

### `.toHaveReturned()`

Également sous l'alias : `.toReturn()`

Si vous disposez d'une fonction fictive, vous pouvez utiliser `.toHaveReturned` pour tester que la fonction fictive est bien retournée (c'est-à-dire qu'elle n'a pas lancé d'erreur) au moins une fois. Par exemple, disons que vous avez une "boisson" fictive qui renvoie `true`. Vous pouvez écrire :

```js
test('drinks returns', () => {
  const drink = jest.fn(() => true);

  drink();

  expect(drink).toHaveReturned();
});
```

### `.toHaveReturnedTimes(number)`

Également sous l'alias : `.toReturnTimes(number)`

Utilisez `.toHaveReturnedTimes` pour vous assurer qu'une fonction fictive est retournée avec succès (c'est-à-dire qu'elle n'a pas lancé d'erreur) un nombre exact de fois. Tout appel à la fonction fictive qui provoque une erreur n'est pas comptabilisé dans le nombre de fois où la fonction est retournée.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie ``true``. Vous pouvez écrire :

```js
test('drink returns twice', () => {
  const drink = jest.fn(() => true);

  drink();
  drink();

  expect(drink).toHaveReturnedTimes(2);
});
```

### `.toHaveReturnedWith(value)`

Également sous l'alias : `.toReturnWith(value)`

Utilisez `.toHaveReturnedWith` pour vous assurer qu'une fonction fictive renvoie une valeur spécifique.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns La Croix', () => {
  const beverage = {name: 'La Croix'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage);

  expect(drink).toHaveReturnedWith('La Croix');
});
```

### `.toHaveLastReturnedWith(value)`

Également sous l'alias : `.lastReturnedWith(value)`

Utilisez `.toHaveLastReturnedWith` pour tester la valeur spécifique qu'une fonction fictive a renvoyée en dernier. Si le dernier appel à la fonction fictive a provoqué une erreur, alors ce comparateur échouera, quelle que soit la valeur que vous avez fournie comme valeur de retour attendue.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns La Croix (Orange) last', () => {
  const beverage1 = {name: 'La Croix (Lemon)'};
  const beverage2 = {name: 'La Croix (Orange)'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveLastReturnedWith('La Croix (Orange)');
});
```

### `.toHaveNthReturnedWith(nthCall, value)`

Également sous l'alias : `.nthReturnedWith(nthCall, value)`

Utilisez `.toHaveNthReturnedWith` pour tester la valeur spécifique qu'une fonction fictive a renvoyée pour le nième appel. Si le nième appel à la fonction fictive a lancé une erreur, alors ce comparateur échouera quelle que soit la valeur que vous avez fournie comme valeur de retour attendue.

Par exemple, disons que vous avez une "boisson" fictive qui renvoie le nom de la boisson qui a été consommée. Vous pouvez écrire :

```js
test('drink returns expected nth calls', () => {
  const beverage1 = {name: 'La Croix (Lemon)'};
  const beverage2 = {name: 'La Croix (Orange)'};
  const drink = jest.fn(beverage => beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)');
  expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');
});
```

Note : le nième argument doit être un nombre entier positif à partir de 1.

### `.toHaveLength(number)`

Utilisez `.toHaveLength` pour vérifier qu'un objet a une propriété `.length` et qu'il est défini à une certaine valeur numérique.

Ceci est particulièrement utile pour vérifier la taille des tableaux ou des chaînes de caractères.

```js
expect([1, 2, 3]).toHaveLength(3);
expect('abc').toHaveLength(3);
expect('').not.toHaveLength(5);
```

### `.toHaveProperty(keyPath, value?)`

Utilisez `.toHaveProperty` pour vérifier si la propriété à la référence fournie `keyPath` existe pour un objet. Pour vérifier les propriétés profondément imbriquées dans un objet, vous pouvez utiliser la [notation par points](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors) ou un tableau contenant le keyPath pour les références profondes.

Vous pouvez fournir un argument optionnel "value" pour comparer la valeur de la propriété reçue (récursivement pour toutes les propriétés des instances d'un objet, également connu sous le nom d'égalité profonde, comme le comparateur "toEqual").

L'exemple suivant contient un objet "houseForSale" avec des propriétés imbriquées. Nous utilisons "toHaveProperty" pour vérifier l'existence et les valeurs des différentes propriétés de l'objet.

```js
// Object containing house features to be tested
const houseForSale = {
  bath: true,
  bedrooms: 4,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    area: 20,
    wallColor: 'white',
    'nice.oven': true,
  },
  'ceiling.height': 2,
};

test('this house has my desired features', () => {
  // Example Referencing
  expect(houseForSale).toHaveProperty('bath');
  expect(houseForSale).toHaveProperty('bedrooms', 4);

  expect(houseForSale).not.toHaveProperty('pool');

  // Deep referencing using dot notation
  expect(houseForSale).toHaveProperty('kitchen.area', 20);
  expect(houseForSale).toHaveProperty('kitchen.amenities', [
    'oven',
    'stove',
    'washer',
  ]);

  expect(houseForSale).not.toHaveProperty('kitchen.open');

  // Deep referencing using an array containing the keyPath
  expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20);
  expect(houseForSale).toHaveProperty(
    ['kitchen', 'amenities'],
    ['oven', 'stove', 'washer'],
  );
  expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven');
  expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']);
  expect(houseForSale).not.toHaveProperty(['kitchen', 'open']);

  // Referencing keys with dot in the key itself
  expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');
});
```

### `.toBeCloseTo(number, numDigits?)`

Utilisez `toBeCloseTo` pour comparer des nombres à virgule flottante pour une égalité approximative.

L'argument optionnel `numDigits` limite le nombre de chiffres à vérifier **après** la virgule décimale. Pour la valeur par défaut `2`, le critère de test est `Math.abs(expected - received) < 0.005` (c'est-à-dire `10 ** -2 / 2`).

Les comparaisons intuitives d'égalité échouent souvent, car l'arithmétique sur les valeurs décimales (base 10) comporte souvent des erreurs d'arrondi dans la représentation binaire de précision limitée (base 2). Par exemple, ce test échoue :

```js
test('adding works sanely with decimals', () => {
  expect(0.2 + 0.1).toBe(0.3); // Fails!
});
```

Il échoue parce qu'en JavaScript, `0.2 + 0.1` est en fait `0.30000000000000004`.

Par exemple, ce test est réussi avec une précision de 5 chiffres :

```js
test('adding works sanely with decimals', () => {
  expect(0.2 + 0.1).toBeCloseTo(0.3, 5);
});
```

Parce que les erreurs en virgule flottante sont le problème que `toBeCloseTo` résout, il ne supporte pas les grandes valeurs entières.

### `.toBeDefined()`

Utilisez `.toBeDefined` pour vérifier qu'une variable n'est pas indéfinie. Par exemple, si vous voulez vérifier qu'une fonction `fetchNewFlavorIdea()` renvoie _quelque chose_, vous pouvez écrire :

```js
test('there is a new flavor idea', () => {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
```

Vous pourriez écrire `expect(fetchNewFlavorIdea()).not.toBe(undefined)`, mais il est préférable d'éviter de faire référence à `undefined` directement dans votre code.

### `.toBeFalsy()`

Utilisez `.toBeFalsy` lorsque vous ne vous souciez pas de la valeur et que vous voulez vous assurer qu'une valeur est fausse dans un contexte booléen. Par exemple, disons que vous avez un code d'application qui ressemble à :

```js
drinkSomeLaCroix();
if (!getErrors()) {
  drinkMoreLaCroix();
}
```

Vous pouvez ne pas vous soucier de ce que `getErrors` renvoie, en particulier - il peut renvoyer `false`, `null`, ou `0`, et votre code fonctionnera quand même. Donc si vous voulez tester qu'il n'y a pas d'erreurs après avoir bu un peu de La Croix, vous pouvez écrire :

```js
test('drinking La Croix does not lead to errors', () => {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
```

En JavaScript, il y a six valeurs erronées : `false`, `0`, `''`, `null`, `undefined`, et `NaN`. Tout le reste est vrai.

### `.toBeGreaterThan(number | bigint)`

Utilisez `toBeGreaterThan` pour comparer `received > expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur de plus de 10 onces :

```js
test('ounces per can is more than 10', () => {
  expect(ouncesPerCan()).toBeGreaterThan(10);
});
```

### `.toBeGreaterThanOrEqual(number | bigint)`

Utilisez `toBeGreaterThanOrEqual` pour comparer `received <= expected` pour les nombres ou les grands nombres. Par exemple, testez que `ouncesPerCan()` renvoie une valeur d'au moins 12 onces :

```js
test('ounces per can is at least 12', () => {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(12);
});
```

### `.toBeLessThan(number | bigint)`

Utilisez `toBeLessThan` pour comparer `received < expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur inférieure à 20 onces :

```js
test('ounces per can is less than 20', () => {
  expect(ouncesPerCan()).toBeLessThan(20);
});
```

### `.toBeLessThanOrEqual(number | bigint)`

Utilisez `toBeLessThanOrEqual` pour comparer `received <= expected` pour des valeurs numériques ou de grands nombres entiers. Par exemple, testez que `ouncesPerCan()` renvoie une valeur d'au plus 12 onces :

```js
test('ounces per can is at most 12', () => {
  expect(ouncesPerCan()).toBeLessThanOrEqual(12);
});
```

### `.toBeInstanceOf(Class)`

Utilisez `.toBeInstanceOf(Class)` pour vérifier qu'un objet est une instance d'une classe. Ce comparateur utilise `instanceof` en dessous.

```js
class A {}

expect(new A()).toBeInstanceOf(A);
expect(() => {}).toBeInstanceOf(Function);
expect(new A()).toBeInstanceOf(Function); // throws
```

### `.toBeNull()`

`.toBeNull()` est le même que `.toBe(null)` mais les messages d'erreur sont un peu plus beaux. Utilisez donc `.toBeNull()` lorsque vous voulez vérifier que quelque chose est nul.

```js
function bloop() {
  return null;
}

test('bloop returns null', () => {
  expect(bloop()).toBeNull();
});
```

### `.toBeTruthy()`

Utilisez `.toBeTruthy` lorsque vous ne vous souciez pas de la valeur et que vous voulez vous assurer qu'une valeur est vraie dans un contexte booléen. Par exemple, disons que vous avez un code d'application qui ressemble à :

```js
drinkSomeLaCroix();
if (thirstInfo()) {
  drinkMoreLaCroix();
}
```

Vous pouvez ne pas vous soucier de ce que `thirstInfo` renvoie, en particulier - il pourrait renvoyer `true` ou un objet complexe, et votre code fonctionnerait toujours. Donc si vous voulez tester que `thirstInfo` sera vrai après avoir bu un peu de La Croix, vous pouvez écrire :

```js
test('drinking La Croix leads to having thirst info', () => {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
```

En JavaScript, il y a six valeurs erronées : `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Tout le reste est vrai.

### `.toBeUndefined()`

Utilisez "toBeUndefined" pour vérifier qu'une variable est bien indéfinie. Par exemple, si vous voulez vérifier qu'une fonction `bestDrinkForFlavor(flavor)` renvoie `undefined` pour la saveur `octopus`, parce qu'il n'y a pas de bonne boisson au goût de pieuvre :

```js
test('the best drink for octopus flavor is undefined', () => {
  expect(bestDrinkForFlavor('octopus')).toBeUndefined();
});
```

Vous pourriez écrire `expect(bestDrinkForFlavor('octopus')).toBe(undefined)`, mais il est préférable d'éviter de faire référence à `undefined` directement dans votre code.

### `.toBeNaN()`

Use `.toBeNaN` when checking a value is `NaN`.

```js
test('passes when value is NaN', () => {
  expect(NaN).toBeNaN();
  expect(1).not.toBeNaN();
});
```

### `.toContain(item)`

Utilisez `.toContain` lorsque vous voulez vérifier qu'un élément se trouve dans un tableau. Pour tester les éléments du tableau, on utilise `===`, une vérification stricte de l'égalité. Le `.toContain` peut également vérifier si une chaîne est une sous-chaîne d'une autre chaîne.

Par exemple, si `getAllFlavors()` renvoie un tableau de saveurs et que vous voulez être sûr que `lime` y est, vous pouvez écrire :

```js
test('the flavor list contains lime', () => {
  expect(getAllFlavors()).toContain('lime');
});
```

### `.toContainEqual(item)`

Utilisez `.toContainEqual` lorsque vous voulez vérifier qu'un élément avec une structure et des valeurs spécifiques est contenu dans un tableau. Pour tester les éléments dans le tableau, cet appariement vérifie récursivement l'égalité de tous les champs, plutôt que de vérifier l'identité de l'objet.

```js
describe('my beverage', () => {
  test('is delicious and not sour', () => {
    const myBeverage = {delicious: true, sour: false};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
```

### `.toEqual(value)`

Utilisez `.toEqual` pour comparer récursivement toutes les propriétés des instances d'objets (aussi appelé égalité "profonde"). Il appelle `Object.is` pour comparer les valeurs primitives, ce qui est encore mieux pour les tests que l'opérateur d'égalité stricte `===`.

Par exemple, `.toEqual` et `.toBe` se comportent différemment dans cette suite de tests, donc tous les tests passent :

```js
const can1 = {
  flavor: 'grapefruit',
  ounces: 12,
};
const can2 = {
  flavor: 'grapefruit',
  ounces: 12,
};

describe('the La Croix cans on my desk', () => {
  test('have all the same properties', () => {
    expect(can1).toEqual(can2);
  });
  test('are not the exact same can', () => {
    expect(can1).not.toBe(can2);
  });
});
```

> Note : `.toEqual` n'effectuera pas une vérification _profonde de l'égalité_ pour deux erreurs. Seule la propriété `message` d'une erreur est prise en compte pour l'égalité. Il est recommandé d'utiliser l'appariement `.toThrow` pour tester les erreurs.

Si les différences entre les propriétés ne vous aident pas à comprendre pourquoi un test échoue, en particulier si le rapport est volumineux, vous pouvez alors déplacer la comparaison dans la fonction "attendre". Par exemple, utilisez la méthode des "égaux" de la classe "buffer" pour déterminer si les tampons contiennent ou non le même contenu :

- réécrivez `expect(received).toEqual(expected)` comme `expect(received.equals(expected)).toBe(true)`.
- réécrire `expect(received).not.toEqual(expected)` comme `expect(received.equals(expected)).toBe(false)`.

### `.toMatch(regexpOrString)`

Utilisez `.toMatch` pour vérifier qu'une chaîne de caractères correspond à une expression régulière.

Par exemple, vous ne savez peut-être pas ce que retourne exactement `essayOnTheBestFlavor()`, mais vous savez que c'est une très longue chaîne, et que la sous-chaîne `grapefruit` devrait être là quelque part. Vous pouvez tester cela avec :

```js
describe('an essay on the best flavor', () => {
  test('mentions grapefruit', () => {
    expect(essayOnTheBestFlavor()).toMatch(/grapefruit/);
    expect(essayOnTheBestFlavor()).toMatch(new RegExp('grapefruit'));
  });
});
```

Ce jumelage accepte également avec une chaîne de caractère, qu'il essaiera de faire correspondre :

```js
describe('grapefruits are healthy', () => {
  test('grapefruits are a fruit', () => {
    expect('grapefruits').toMatch('fruit');
  });
});
```

### `.toMatchObject(object)`

Utilisez `.toMatchObject` pour vérifier qu'un objet JavaScript correspond à un sous-ensemble des propriétés d'un objet. Il fera correspondre les objets reçus avec les propriétés qui ne sont pas **non** dans l'objet attendu.

Vous pouvez également passer un tableau d'objets, auquel cas la méthode ne retournera vrai que si chaque objet du tableau reçu correspond (au sens "toMatchObject" décrit ci-dessus) à l'objet correspondant du tableau attendu. Ceci est utile si vous voulez vérifier que deux tableaux correspondent dans leur nombre d'éléments, par opposition à "arrayContaining", qui permet d'ajouter des éléments supplémentaires dans le tableau reçu.

Vous pouvez faire correspondre des propriétés à des valeurs ou à des éléments correspondants.

```js
const houseForSale = {
  bath: true,
  bedrooms: 4,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    area: 20,
    wallColor: 'white',
  },
};
const desiredHouse = {
  bath: true,
  kitchen: {
    amenities: ['oven', 'stove', 'washer'],
    wallColor: expect.stringMatching(/white|yellow/),
  },
};

test('the house has my desired features', () => {
  expect(houseForSale).toMatchObject(desiredHouse);
});
```

```js
describe('toMatchObject applied to arrays', () => {
  test('the number of elements must match exactly', () => {
    expect([{foo: 'bar'}, {baz: 1}]).toMatchObject([{foo: 'bar'}, {baz: 1}]);
  });

  test('.toMatchObject is called for each elements, so extra object properties are okay', () => {
    expect([{foo: 'bar'}, {baz: 1, extra: 'quux'}]).toMatchObject([
      {foo: 'bar'},
      {baz: 1},
    ]);
  });
});
```

### `.toMatchSnapshot(propertyMatchers?, hint?)`

Cela permet de s'assurer qu'une valeur correspond à l'instantané le plus récent. Consultez le [guide de test des instantanés] (SnapshotTesting.md) pour plus d'informations.

Vous pouvez fournir un argument optionnel pour l'objet `propertyMatchers`, qui a des matchers asymétriques comme valeurs d'un sous-ensemble de propriétés attendues, **si** la valeur reçue sera une instance **objet**. C'est comme un `toMatchObject` avec des critères flexibles pour un sous-ensemble de propriétés, suivi d'un test d'instantané comme critère exact pour le reste des propriétés.

Vous pouvez fournir un argument optionnel sous forme de chaîne de caractères "indice" qui est ajouté au nom du test. Bien que Jest ajoute toujours un nombre à la fin du nom de l'instantané, de courts indices descriptifs peuvent être plus utiles que des nombres pour différencier les **multiples** instantanés dans un bloc **single** `it` ou `test`. Jest trie les instantanés par nom dans le fichier ".snap" correspondant.

### `.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)`

S'assure qu'une valeur correspond à l'instantané le plus récent.

Vous pouvez fournir un argument optionnel pour l'objet `propertyMatchers`, qui a des matchers asymétriques comme valeurs d'un sous-ensemble de propriétés attendues, **si** la valeur reçue sera une instance **objet**. C'est comme un `toMatchObject` avec des critères flexibles pour un sous-ensemble de propriétés, suivi d'un test d'instantané comme critère exact pour le reste des propriétés.

Jest ajoute l'argument chaîne `inlineSnapshot` au matchcher dans le fichier de test (au lieu d'un fichier `.snap` externe) la première fois que le test est exécuté.

Consultez la section [Inline Snapshots](SnapshotTesting.md#inline-snapshots) pour plus d'informations.

### `.toStrictEqual(value)`

Utilisez `.toStrictEqual` pour tester que les objets ont les mêmes types ainsi que la même structure.

Différences par rapport à `.toEqual` :

- Les clés avec des propriétés `undefined` sont vérifiées. Par exemple, `{a : undefined, b : 2}` ne correspond pas à `{b: 2}` lorsque l'on utilise le `.toStrictEqual`.
- La dispersion des tableaux est vérifiée. par exemple, `[, 1]` ne correspond pas à `[undefined, 1]` quand on utilise `.toStrictEqual`.
- Les types d'objets sont vérifiés pour être égaux. Par exemple, une instance de classe avec les champs `a` et `b` ne sera pas égale à un objet littéral avec les champs `a` et `b`.

```js
class LaCroix {
  constructor(flavor) {
    this.flavor = flavor;
  }
}

describe('the La Croix cans on my desk', () => {
  test('are not semantically the same', () => {
    expect(new LaCroix('lemon')).toEqual({flavor: 'lemon'});
    expect(new LaCroix('lemon')).not.toStrictEqual({flavor: 'lemon'});
  });
});
```

### `.toThrow(error?)`

Également sous le pseudonyme : ".toThrowError(error ?)`

Utilisez `.toThrow` pour tester qu'une fonction lance lorsqu'elle est appelée. Par exemple, si nous voulons tester le lancer de `drinkFlavor('octopus')`, parce que la saveur du poulpe est trop dégoûtante pour être bue, nous pouvons écrire :

```js
test('throws on octopus', () => {
  expect(() => {
    drinkFlavor('octopus');
  }).toThrow();
});
```

> Note : Vous devez envelopper le code dans une fonction, sinon l'erreur ne sera pas détectée et l'assertion échouera.

Vous pouvez fournir un argument optionnel pour vérifier qu'une erreur spécifique est lancée :

- expression régulière : message d'erreur **correspond au modèle
- string : message d'erreur **inclut** la sous-chaîne
- objet d'erreur : le message d'erreur est **égale à** la propriété de message de l'objet
- classe d'erreur : l'objet d'erreur est **instance de** classe

Par exemple, disons que `drinkFlavor` est codé comme ceci :

```js
function drinkFlavor(flavor) {
  if (flavor == 'octopus') {
    throw new DisgustingFlavorError('yuck, octopus flavor');
  }
  // Faire d'autres choses
}
```

Nous pourrions tester cette erreur est jetée de plusieurs façons :

```js
test('throws on octopus', () => {
  function drinkOctopus() {
    drinkFlavor('octopus');
  }

  // Vérifiez que le message d'erreur dit "beurk" quelque part : ils sont équivalents
  expect(drinkOctopus).toThrowError(/yuck/);
  expect(drinkOctopus).toThrowError('yuck');

  // Tester le message d'erreur exact
  expect(drinkOctopus).toThrowError(/^yuck, octopus flavor$/);
  expect(drinkOctopus).toThrowError(new Error('yuck, octopus flavor'));

  // Tester que nous obtenons une erreur de goût dégoûtante
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
```

### `.toThrowErrorMatchingSnapshot(hint?)`

Utilisez `.toThrowErrorMatchingSnapshot` pour tester qu'une fonction lance une erreur correspondant à l'instantané le plus récent lorsqu'elle est appelée.

Vous pouvez fournir un argument optionnel sous forme de chaîne de caractères `hint` qui est ajouté au nom du test. Bien que Jest ajoute toujours un nombre à la fin du nom de l'instantané, de courts indices descriptifs peuvent être plus utiles que des nombres pour différencier les **multiples** instantanés dans un bloc **single** `it` ou `test`. Jest trie les instantanés par nom dans le fichier ".snap" correspondant.

Par exemple, disons que vous avez une fonction `drinkFlavor` qui lance chaque fois que la saveur est `'octopus'`, et qui est codée comme ceci :

```js
function drinkFlavor(flavor) {
  if (flavor == 'octopus') {
    throw new DisgustingFlavorError('yuck, octopus flavor');
  }
  // Faire d'autres choses
}
```

Le test de cette fonction se présentera ainsi :

```js
test('throws on octopus', () => {
  function drinkOctopus() {
    drinkFlavor('octopus');
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
```

Et il générera l'instantané suivant :

```js
exports[`drinking flavors throws on octopus 1`] = `"yuck, octopus flavor"`;
```

Consultez le site [React Tree Snapshot Testing] (https://jestjs.io/blog/2016/07/27/jest-14.html) pour plus d'informations sur les tests instantanés.

### `.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)`

Utilisez `.toThrowErrorMatchingInlineSnapshot` pour tester qu'une fonction lance une erreur correspondant à l'instantané le plus récent lorsqu'elle est appelée.

Jest ajoute l'argument chaîne `inlineSnapshot` au matcher dans le fichier de test (au lieu d'un fichier externe `.snap`) la première fois que le test est lancé.

Consultez la section [Inline Snapshots](SnapshotTesting.md#inline-snapshots) pour plus d'informations.


# Les fonctions simulées

Les fonctions fictives sont également appelées "espions", car elles vous permettent d'espionner le comportement d'une fonction qui est appelée indirectement par un autre code, plutôt que de tester uniquement la sortie. Vous pouvez créer une fonction fictive avec `jest.fn()`. Si aucune implémentation n'est donnée, la fonction fantaisie retournera `undefined` lorsqu'elle sera invoquée.

## Les méthodes

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Référence

### `mockFn.getMockName()`

Renvoie la chaîne de nom fictif définie en appelant `mockFn.mockName(value)`.

### `mockFn.mock.calls`

Un tableau contenant les arguments d'appel de tous les appels qui ont été faits à cette fonction fictive. Chaque élément du tableau est un tableau d'arguments qui ont été passés pendant l'appel.

Par exemple : Une fonction fictive `f` qui a été appelée deux fois, avec les arguments `f('arg1', 'arg2')`, et ensuite avec les arguments `f('arg3', 'arg4')`, aurait un tableau `mock.calls` qui ressemble à ceci :

```js
[
  ['arg1', 'arg2'],
  ['arg3', 'arg4'],
];
```

### `mockFn.mock.results`

Un tableau contenant les résultats de tous les appels qui ont été passés à cette fonction fictive. Chaque entrée de ce tableau est un objet contenant une propriété  `type` et une propriété  `valeur`. Le `type` sera l'un des objets suivants :

- `'return'` - Indique que l'appel s'est terminé par un retour normal.
-`'throw'` - Indique que l'appel s'est terminé par le lancement d'une valeur.
-`'incomplete'` - Indique que l'appel n'est pas encore terminé. Cela se produit si vous testez depuis la fonction fictive elle-même, ou depuis une fonction qui a été appelée par la simulation.

La propriété `value` contient la valeur qui a été lancée ou retournée. La valeur est indéfinie lorsque le `type === 'incomplete'`.

Par exemple : Une fonction fictive `f` qui a été appelée trois fois, retournant `'result1'`, lançant une erreur, et retournant ensuite `'result2'`, aurait un tableau `mock.results` qui ressemble à ceci :

```js
[
  {
    type: 'return',
    value: 'result1',
  },
  {
    type: 'throw',
    value: {
      /* Error instance */
    },
  },
  {
    type: 'return',
    value: 'result2',
  },
];
```

### `mockFn.mock.instances`

Un tableau qui contient toutes les instances d'objets qui ont été instanciées à partir de cette fonction fictive en utilisant `new`.

Par exemple : Une fonction fantaisie qui a été instanciée deux fois aura le tableau suivant `mock.instances` :

```js
const mockFn = jest.fn();

const a = new mockFn();
const b = new mockFn();

mockFn.mock.instances[0] === a; // true
mockFn.mock.instances[1] === b; // true
```

### `mockFn.mockClear()`

Réinitialise toutes les informations stockées dans les tableaux [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances).

C'est souvent utile lorsque vous voulez nettoyer les données d'utilisation d'un faux entre deux assertions.

Attention, `mockClear` remplacera `mockFn.mock`, et pas seulement [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances). Vous devez donc éviter d'assigner `mockFn.mock` à d'autres variables, temporaires ou non, pour vous assurer que vous n'accédez pas à des données périmées.

L'option de configuration [`clearMocks`](configuration.html#clearmocks-boolean) est disponible pour effacer automatiquement les mocks entre les tests.

### `mockFn.mockReset()`

Fait tout ce que fait [`mockFn.mockClear()`](#mockfnmockclear), et supprime également toute valeur de retour ou implémentation simulée.

C'est utile lorsque vous souhaitez réinitialiser complètement un _mock_ à son état initial. (Notez que la réinitialisation d'un _espion_ résultera en une fonction sans valeur de retour).

Attention, `mockReset` remplacera `mockFn.mock`, pas seulement [`mockFn.mock.calls`](#mockfnmockcalls) et [`mockFn.mock.instances`](#mockfnmockinstances). Vous devez donc éviter d'assigner `mockFn.mock` à d'autres variables, temporaires ou non, pour vous assurer que vous n'accédez pas à des données périmées.

### `mockFn.mockRestore()`

Fait tout ce que fait [`mockFn.mockReset()`](#mockfnmockreset), et restaure également l'implémentation originale (non simulée).

Ceci est utile lorsque vous souhaitez simuler des fonctions dans certains cas de test et restaurer l'implémentation originale dans d'autres.

Attention, `mockFn.mockRestore` ne fonctionne que lorsque la mock a été créée avec `jest.spyOn`. Vous devez donc vous occuper vous-même de la restauration lorsque vous assignez manuellement `jest.fn()`.

L'option de configuration [`restoreMocks`](configuration.html#restoremocks-boolean) est disponible pour restaurer automatiquement les mocks entre les tests.

### `mockFn.mockImplementation(fn)`

Accepte une fonction qui devrait être utilisée comme la mise en œuvre de la simulation. La simulation elle-même enregistrera tous les appels qui entrent et les instances qui viennent d'elle-même - la seule différence est que l'implémentation sera également exécutée lorsque la simulation sera appelée.

_Note : `jest.fn(implementation)` est un raccourci pour `jest.fn().mockImplementation(implementation)`._

For example:

```js
const mockFn = jest.fn().mockImplementation(scalar => 42 + scalar);
// or: jest.fn(scalar => 42 + scalar);

const a = mockFn(0);
const b = mockFn(1);

a === 42; // true
b === 43; // true

mockFn.mock.calls[0][0] === 0; // true
mockFn.mock.calls[1][0] === 1; // true
```

`mockImplementation` peut également être utilisé pour simuler des constructeurs de classe :

```js
// SomeClass.js
module.exports = class SomeClass {
  m(a, b) {}
};

// OtherModule.test.js
jest.mock('./SomeClass'); // cela se produit automatiquement avec l'automatisation
const SomeClass = require('./SomeClass');
const mMock = jest.fn();
SomeClass.mockImplementation(() => {
  return {
    m: mMock,
  };
});

const some = new SomeClass();
some.m('a', 'b');
console.log('Calls to m: ', mMock.mock.calls);
```

### `mockFn.mockImplementationOnce(fn)`

Accepte une fonction qui sera utilisée comme une implémentation de la fonction simulée pour un appel à la fonction simulée. Peut-être enchaîné de manière à ce que plusieurs appels de fonction produisent des résultats différents.

```js
const myMockFn = jest
  .fn()
  .mockImplementationOnce(cb => cb(null, true))
  .mockImplementationOnce(cb => cb(null, false));

myMockFn((err, val) => console.log(val)); // Vrai

myMockFn((err, val) => console.log(val)); // FAux
```

Lorsque la fonction simulée est à court d'implémentations définies avec mockImplementationOnce, elle exécutera l'implémentation par défaut définie avec `jest.fn(() => defaultValue)` ou `.mockImplementation(() => defaultValue)` si elles ont été appelées :

```js
const myMockFn = jest
  .fn(() => 'default')
  .mockImplementationOnce(() => 'first call')
  .mockImplementationOnce(() => 'second call');

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### `mockFn.mockName(value)`

Accepte une chaîne à utiliser dans la sortie des résultats de test à la place de "jest.fn()" pour indiquer quelle fonction fictive est référencée.

Par exemple :

```js
const mockFn = jest.fn().mockName('mockedFunction');
// mockFn();
expect(mockFn).toHaveBeenCalled();
```

entraînera cette erreur :

```
expect(mockedFunction).toHaveBeenCalled()

Expected mock function "mockedFunction" to have been called, but it was not called.
```

### `mockFn.mockReturnThis()`

Fonction de sucre syntactique pour :

```js
jest.fn(function () {
  return this;
});
```

### `mockFn.mockReturnValue(value)`

Accepte une valeur qui sera retournée chaque fois que la fonction fictive est appelée.

```js
const mock = jest.fn();
mock.mockReturnValue(42);
mock(); // 42
mock.mockReturnValue(43);
mock(); // 43
```

### `mockFn.mockReturnValueOnce(value)`

Accepte une valeur qui sera renvoyée pour un appel à la fonction fictive. Peut-être enchaînée de sorte que les appels successifs à la fonction fictive renvoient des valeurs différentes. Lorsqu'il n'y a plus de valeurs `mockReturnValueOnce` à utiliser, les appels retourneront une valeur spécifiée par `mockReturnValue`.

```js
const myMockFn = jest
  .fn()
  .mockReturnValue('default')
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call');

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### `mockFn.mockResolvedValue(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementation(() => Promise.resolve(value));
```

Utile pour simuler les fonctions d'asynchronisation dans les tests d'asynchronisation :

```js
test('async test', async () => {
  const asyncMock = jest.fn().mockResolvedValue(43);

  await asyncMock(); // 43
});
```

### `mockFn.mockResolvedValueOnce(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
```

Utile pour simuler les fonctions d'asynchronisation dans les tests d'asynchronisation :

```js
test('async test', async () => {
  const asyncMock = jest
    .fn()
    .mockResolvedValue('default')
    .mockResolvedValueOnce('first call')
    .mockResolvedValueOnce('second call');

  await asyncMock(); // first call
  await asyncMock(); // second call
  await asyncMock(); // default
  await asyncMock(); // default
});
```

### `mockFn.mockRejectedValue(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementation(() => Promise.reject(value));
```

Utile pour créer des fonctions asynchrones fictives qui seront toujours rejetées :

```js
test('async test', async () => {
  const asyncMock = jest.fn().mockRejectedValue(new Error('Async error'));

  await asyncMock(); // throws "Async error"
});
```

### `mockFn.mockRejectedValueOnce(value)`

Fonction de sucre syntactique pour :

```js
jest.fn().mockImplementationOnce(() => Promise.reject(value));
```

Exemple d'utilisation :

```js
test('async test', async () => {
  const asyncMock = jest
    .fn()
    .mockResolvedValueOnce('first call')
    .mockRejectedValueOnce(new Error('Async error'));

  await asyncMock(); // first call
  await asyncMock(); // throws "Async error"
});
```


# L'objet Jest

L'objet "jest" est automatiquement dans le champ d'application de chaque fichier de test. Les méthodes de l'objet `jest` aident à créer des simulations et vous permettent de contrôler le comportement général de Jest. Il peut également être importé explicitement par l'intermédiaire de `import {jest} de '@jest/globals'.

## Modules fictifs

### `jest.disableAutomock()`

Désactive la simulation automatique dans le chargeur de modules.

> Voir la section `automock` de [configuration](Configuration.md#automock-boolean) for more information

Après l'appel de cette méthode, tous les `require()`s renverront les versions réelles de chaque module (plutôt qu'une version fictive).

Configuration de Jest :

```json
{
  "automock": true
}
```

Exemple :

```js
// utils.js
export default {
  authorize: () => {
    return 'token';
  },
};
```

```js
// __tests__/disableAutomocking.js
import utils from '../utils';

jest.disableAutomock();

test('original implementation', () => {
  // Nous avons maintenant la mise en œuvre originale,
  // même si on met l'automocking dans une configuration de Jest
  expect(utils.authorize()).toBe('token');
});
```

Cela est généralement utile lorsque vous avez un scénario dans lequel le nombre de dépendances dont vous voulez vous moquer est bien inférieur à celui des dépendances dont vous ne voulez pas. Par exemple, si vous écrivez un test pour un module qui utilise un grand nombre de dépendances qui peuvent être raisonnablement classées comme "détails d'implémentation" du module, alors vous ne voulez probablement pas vous moquer de ces dépendances.

Les exemples de dépendances qui peuvent être considérées comme des "détails d'implémentation" sont des choses qui vont de l'intégration du langage (par exemple, les méthodes Array.prototype) à des méthodes d'utilité très courantes (par exemple, les utilitaires underscore/lo-dash, array, etc) et des bibliothèques entières comme React.js.

Retourne l'objet "jest" pour le chaînage.

_Note : cette méthode était auparavant appelée `autoMockOff`. Lorsque vous utilisez `babel-jest`, les appels à `disableAutomock` seront automatiquement hissés en haut du bloc de code. Utilisez `autoMockOff` si vous voulez éviter explicitement ce comportement._

### `jest.enableAutomock()`

Permet la simulation automatique dans le chargeur de modules.

Retourne l'objet `jest` pour le chaînage.

> Voir la section `automock` de [configuration](Configuration.md#automock-boolean) pour plus d'informations

Exemple :

```js
// utils.js
export default {
  authorize: () => {
    return 'token';
  },
  isAuthorized: secret => secret === 'wizard',
};
```

```js
// __tests__/enableAutomocking.js
jest.enableAutomock();

import utils from '../utils';

test('original implementation', () => {
  // now we have the mocked implementation,
  expect(utils.authorize._isMockFunction).toBeTruthy();
  expect(utils.isAuthorized._isMockFunction).toBeTruthy();
});
```

_Note : cette méthode était auparavant appelée "autoMockOn". Lors de l'utilisation de `babel-jest`, les appels à `enableAutomock` seront automatiquement hissés en haut du bloc de code. Utilisez `autoMockOn` si vous voulez éviter explicitement ce comportement._

### `jest.createMockFromModule(moduleName)`

##### renamed in Jest **26.0.0+**

Aussi sous l'alias : `.genMockFromModule(moduleName)`

En donnant le nom d'un module, utilisez le système de simulation automatique pour générer une version fictive du module pour vous.

Ceci est utile lorsque vous souhaitez créer une [simulation manuelle] (ManualMocks.md) qui étend le comportement de la simulation automatique.

Exemple :

```js
// utils.js
export default {
  authorize: () => {
    return 'token';
  },
  isAuthorized: secret => secret === 'wizard',
};
```

```js
// __tests__/createMockFromModule.test.js
const utils = jest.createMockFromModule('../utils').default;
utils.isAuthorized = jest.fn(secret => secret === 'not wizard');

test('implementation created by jest.createMockFromModule', () => {
  expect(utils.authorize.mock).toBeTruthy();
  expect(utils.isAuthorized('not wizard')).toEqual(true);
});
```

C'est ainsi que `createMockFromModule` simulera des types de données suivants :

#### `Function`

Crée une nouvelle [fonction fictive] (https://jestjs.io/docs/en/mock-functions.html). La nouvelle fonction n'a pas de paramètres formels et, lorsqu'elle est appelée, elle retourne `undefined`. Cette fonctionnalité s'applique également aux fonctions `async`.

#### `Class`

Crée une nouvelle classe. L'interface de la classe originale est conservée, toutes les fonctions et propriétés des membres de la classe seront simulées.

#### `Object`

Crée un nouvel objet profondément cloné. Les clés des objets sont conservées et leurs valeurs sont bafouées.

#### `Array`

Crée un nouveau tableau vide, en ignorant l'original.

#### `Primitives`

Crée une nouvelle propriété ayant la même valeur primitive que la propriété d'origine.

Exemple :

```
// example.js
module.exports = {
  function: function square(a, b) {
    return a * b;
  },
  asyncFunction: async function asyncSquare(a, b) {
    const result = await a * b;
    return result;
  },
  class: new class Bar {
    constructor() {
      this.array = [1, 2, 3];
    }
    foo() {}
  },
  object: {
    baz: 'foo',
    bar: {
      fiz: 1,
      buzz: [1, 2, 3],
    },
  },
  array: [1, 2, 3],
  number: 123,
  string: 'baz',
  boolean: true,
  symbol: Symbol.for('a.b.c'),
};
```

```js
// __tests__/example.test.js
const example = jest.createMockFromModule('./example');

test('should run example code', () => {
  // crée une nouvelle fonction simulée sans arguments formels.
  expect(example.function.name).toEqual('square');
  expect(example.function.length).toEqual(0);

  // Les fonctions asynchrones reçoivent le même traitement que les fonctions synchrones standard.
  expect(example.asyncFunction.name).toEqual('asyncSquare');
  expect(example.asyncFunction.length).toEqual(0);

  // crée une nouvelle classe avec la même interface, les fonctions et propriétés des membres sont simulées.
  expect(example.class.constructor.name).toEqual('Bar');
  expect(example.class.foo.name).toEqual('foo');
  expect(example.class.array.length).toEqual(0);

  // crée une version profondément clonée de l'objet original.
  expect(example.object).toEqual({
    baz: 'foo',
    bar: {
      fiz: 1,
      buzz: [],
    },
  });

  // crée un nouveau tableau vide, en ignorant le tableau original.
  expect(example.array.length).toEqual(0);

  // crée une nouvelle propriété ayant la même valeur primitive que la propriété d'origine.
  expect(example.number).toEqual(123);
  expect(example.string).toEqual('baz');
  expect(example.boolean).toEqual(true);
  expect(example.symbol).toEqual(Symbol.for('a.b.c'));
});
```

### `jest.mock(moduleName, factory, options)`

Il simule un module avec une version auto-mockée lorsqu'il est requis. Les options "usine" et "options" sont facultatives. Par exemple :

```js
// banana.js
module.exports = () => 'banana';

// __tests__/test.js
jest.mock('../banana');

const banana = require('../banana'); // banana sera explicitement  simulé.

banana(); // reviendra  'undefined' car la fonction est auto-mockée.
```

Le deuxième argument peut être utilisé pour spécifier une usine de modules explicite qui est en cours d'exécution au lieu d'utiliser la fonction d'auto-marquage de Jest :

```js
jest.mock('../moduleName', () => {
  return jest.fn(() => 42);
});

// Ceci exécute la fonction spécifiée en second argument de `jest.mock`.
const moduleName = require('../moduleName');
moduleName(); // Will return '42';
```

Lorsque l'on utilise le paramètre `factory` pour un module ES6 avec un export par défaut, la propriété "esModule : true" doit être spécifiée. Cette propriété est normalement générée par Babel / TypeScript, mais ici elle doit être définie manuellement. Lors de l'importation d'un export par défaut, il s'agit d'une instruction d'importer la propriété nommée "default" de l'objet d'export :

```js
import moduleName, {foo} from '../moduleName';

jest.mock('../moduleName', () => {
  return {
    __esModule: true,
    default: jest.fn(() => 42),
    foo: jest.fn(() => 43),
  };
});

moduleName(); // Will return 42
foo(); // Will return 43
```

Le troisième argument peut être utilisé pour créer des maquettes virtuelles - des simulations de modules qui n'existent nulle part dans le système :

```js
jest.mock(
  '../moduleName',
  () => {
    /*
      * Implémentation personnalisée d'un module qui n'existe pas dans JS,
      * comme un module généré ou un module natif en react-native.
     */
  },
  {virtual: true},
);
```

> **Warning:** L'importation d'un module dans un fichier de configuration (comme spécifié par `setupTestFrameworkScriptFile`) empêchera la simulation pour le module en question, ainsi que pour tous les modules qu'il importe.

Les modules dont on simule avec `jest.mock` ne le sont que pour le fichier qui s'appelle `jest.mock`. Un autre fichier qui importe le module obtiendra l'implémentation originale même s'il s'exécute après le fichier de test qui se moque du module.

Retourne l'objet `jest` pour le chaînage.

### `jest.unmock(moduleName)`

Indique que le système de modules ne doit jamais renvoyer une version fictive du module spécifié à partir de `require()` (par exemple, qu'il doit toujours renvoyer le module réel).

L'utilisation la plus courante de cette API est la spécification du module qu'un test donné a l'intention de tester (et ne veut donc pas être automatiquement simulé).

Retourne l'objet `jest` pour le chaînage.

### `jest.doMock(moduleName, factory, options)`

Lorsque vous utilisez `babel-jest`, les appels à `mock` seront automatiquement hissés en haut du bloc de code. Utilisez cette méthode si vous voulez éviter explicitement ce comportement.

Un exemple d'utilité est lorsque vous voulez simuler un module différemment dans le même fichier :

```js
beforeEach(() => {
  jest.resetModules();
});

test('moduleName 1', () => {
  jest.doMock('../moduleName', () => {
    return jest.fn(() => 1);
  });
  const moduleName = require('../moduleName');
  expect(moduleName()).toEqual(1);
});

test('moduleName 2', () => {
  jest.doMock('../moduleName', () => {
    return jest.fn(() => 2);
  });
  const moduleName = require('../moduleName');
  expect(moduleName()).toEqual(2);
});
```

L'utilisation de `jest.doMock()` avec les importations ES6 nécessite des étapes supplémentaires. Suivez ces étapes si vous ne voulez pas utiliser `require` dans vos tests :

- Nous devons spécifier la propriété `__esModule : true` (voir l'API [`jest.mock()`](#jestmockmodulename-factory-options) pour plus d'informations).
- Les importations de modules ES6 statiques sont placées en haut du fichier, donc nous devons les importer dynamiquement en utilisant `import()`.
- Enfin, nous avons besoin d'un environnement qui supporte l'importation dynamique. Veuillez consulter [Using Babel](GettingStarted.md#using-babel) pour la configuration initiale. Ensuite, ajoutez le plugin [babel-plugin-dynamic-import-node](https://www.npmjs.com/package/babel-plugin-dynamic-import-node), ou un équivalent, à votre configuration Babel pour permettre l'importation dynamique dans Node.


```js
beforeEach(() => {
  jest.resetModules();
});

test('moduleName 1', () => {
  jest.doMock('../moduleName', () => {
    return {
      __esModule: true,
      default: 'default1',
      foo: 'foo1',
    };
  });
  return import('../moduleName').then(moduleName => {
    expect(moduleName.default).toEqual('default1');
    expect(moduleName.foo).toEqual('foo1');
  });
});

test('moduleName 2', () => {
  jest.doMock('../moduleName', () => {
    return {
      __esModule: true,
      default: 'default2',
      foo: 'foo2',
    };
  });
  return import('../moduleName').then(moduleName => {
    expect(moduleName.default).toEqual('default2');
    expect(moduleName.foo).toEqual('foo2');
  });
});
```

Renvoie l'objet `jest` pour l'enchaînement.

### `jest.dontMock(moduleName)`

Lorsque vous utilisez `babel-jest`, les appels à `unmock` seront automatiquement hissés en haut du bloc de code. Utilisez cette méthode si vous voulez éviter explicitement ce comportement.

Renvoie l'objet "plaisanterie" pour l'enchaînement.

### `jest.setMock(moduleName, moduleExports)`

Fournit explicitement l'objet fictif que le système de modules doit retourner pour le module spécifié.

Il arrive parfois que la maquette générée automatiquement par le système de modules que vous devriez normalement recevoir ne soit pas suffisante pour vos besoins de test. Normalement, dans ces circonstances, vous devez écrire une [maquette manuelle] (ManualMocks.md) qui est plus adéquate pour le module en question. Toutefois, dans de très rares cas, même une maquette manuelle ne convient pas à vos besoins et vous devez la construire vous-même dans le cadre de votre test.

Dans ces rares cas, vous pouvez utiliser cette API pour remplir manuellement l'emplacement dans le registre des modules de la maquette du système de modules.

Renvoie l'objet "Jest" pour l'enchaînement.

_Note Il est recommandé d'utiliser [`jest.mock()`](#jestmockmodulename-factory-options) à la place. Le second argument de l'API `jest.mock` est une usine de modules au lieu de l'objet module exporté attendu._

### `jest.requireActual(moduleName)`

Renvoie le module réel au lieu d'un module fictif, en contournant tous les contrôles pour savoir si le module doit recevoir une implémentation fictive ou non.

Exemple :

```js
jest.mock('../myModule', () => {
  // Exiger que le module d'origine ne soit pas fictif...
  const originalModule = jest.requireActual('../myModule');

  return {
    __esModule: true, // A utiliser lorsque vous traitez avec les esModules
    ...originalModule,
    getRandom: jest.fn().mockReturnValue(10),
  };
});

const getRandom = require('../myModule').getRandom;

getRandom(); // Always returns 10
```

### `jest.requireMock(moduleName)`

Renvoie un module fictif au lieu du module réel en contournant tous les contrôles pour savoir si le module doit être requise normalement ou non.

### `jest.resetModules()`

Réinitialise le registre des modules - le cocha de tous les modules requis. Ceci est utile pour isoler les modules où l'état local pourrait entrer en conflit entre les tests.

Example:

```js
const sum1 = require('../sum');
jest.resetModules();
const sum2 = require('../sum');
sum1 === sum2;
// > faux (les deux modules de la somme sont des "instances" distinctes du module de la somme).
```

Exemple dans un test :

```js
beforeEach(() => {
  jest.resetModules();
});

test('works', () => {
  const sum = require('../sum');
});

test('works too', () => {
  const sum = require('../sum');
  // Sum est une copie différente du module sum du test précédent.
});
```

Renvoie l'objet `jest` pour l'enchaînement.

### `jest.isolateModules(fn)`

Le module `jest.isolateModules(fn)` va plus loin que `jest.resetModules()` et crée un registre sandbox pour les modules qui sont chargés à l'intérieur de la fonction de callback. Ceci est utile pour isoler des modules spécifiques pour chaque test afin que l'état local du module ne soit pas en conflit entre les tests.

```js
let myModule;
jest.isolateModules(() => {
  myModule = require('myModule');
});

const otherCopyOfMyModule = require('myModule');
```

## Les fonctions fictifs

### `jest.fn(implementation)`

Renvoie une nouvelle [fonction fictive] non utilisée (MockFunctionAPI.md). Optionnellement, prend une implémentation fictive.

```js
const mockFn = jest.fn();
mockFn();
expect(mockFn).toHaveBeenCalled();

// Avec une mise en œuvre simulée :
const returnsTrue = jest.fn(() => true);
console.log(returnsTrue()); // true;
```

### `jest.isMockFunction(fn)`

Détermine si la fonction donnée est une fonction simulée.

### `jest.spyOn(object, methodName)`

Créer une fonction similaire à `jest.fn` mais suit également les appels à `object[methodName]`. Renvoie un Jeset [fonction fictive](MockFunctionAPI.md).

_Note : Par défaut, `jest.spyOn` appelle aussi la méthode **spy**. C'est un comportement différent de la plupart des autres bibliothèques de test. Si vous voulez écraser la fonction originale, vous pouvez utiliser `jest.spyOn(object, methodName).mockImplementation(() => customImplementation)` ou `object[methodName] = jest.fn(() => customImplementation);`_

Exemple :

```js
const video = {
  play() {
    return true;
  },
};

module.exports = video;
```

Exemple de test :

```js
const video = require('./video');

test('plays video', () => {
  const spy = jest.spyOn(video, 'play');
  const isPlaying = video.play();

  expect(spy).toHaveBeenCalled();
  expect(isPlaying).toBe(true);

  spy.mockRestore();
});
```

### `jest.spyOn(object, methodName, accessType?)`

Depuis Jest 22.1.0+, la méthode `jest.spyOn` prend un troisième argument optionnel de `accessType` qui peut être soit `'get'' soit `'set'', qui s'avère utile lorsque vous voulez espionner un getter ou un setter, respectivement.

Exemple :

```js
const video = {
  // C'est un getter!
  get play() {
    return true;
  },
};

module.exports = video;

const audio = {
  _volume: false,
  // C'est un setter!
  set volume(value) {
    this._volume = value;
  },
  get volume() {
    return this._volume;
  },
};

module.exports = audio;
```

Example test:

```js
const video = require('./video');

test('plays video', () => {
  const spy = jest.spyOn(video, 'play', 'get'); // Nous passons 'get'
  const isPlaying = video.play;

  expect(spy).toHaveBeenCalled();
  expect(isPlaying).toBe(true);

  spy.mockRestore();
});

const audio = require('./audio');

test('plays audio', () => {
  const spy = jest.spyOn(audio, 'volume', 'set'); // Nous passons 'set'
  audio.volume = 100;

  expect(spy).toHaveBeenCalled();
  expect(audio.volume).toBe(100);

  spy.mockRestore();
});
```

### `jest.clearAllMocks()`

Efface les propriétés `mock.calls` et `mock.instances` de tous les simulations. Cela équivaut à appeler [`.mockClear()`](MockFunctionAPI.md#mockfnmockclear) sur chaque fonction fantaisie.

Retourne l'objet `jest` pour le chaînage.

### `jest.resetAllMocks()`

Rétablit l'état de toutes les simulations. Cela équivaut à appeler  [`.mockReset()`](MockFunctionAPI.md#mockfnmockreset) sur chaque fonction simulée.

Retourne l'objet `jest` pour le chaînage.

### `jest.restoreAllMocks()`

Rétablit la valeur d'origine de toutes les simulations. Cela équivaut à appeler [`.mockRestore()`](MockFunctionAPI.md#mockfnmockrestore) sur chaque fonction simulée. Attention, `jest.restoreAllMocks()` ne fonctionne que lorsque la simulation a été créé avec `jest.spyOn` ; les autres simulations nécessiteront que vous les restauriez manuellement.

## Minuteries factices

### `jest.useFakeTimers(implementation?: 'modern' | 'legacy')`

Demande à Jest d'utiliser des versions factices des fonctions standard de la minuterie (`setTimeout`, `setIntervalle`, `clearTimeout`, `clearIntervalle`, `nextTick`, `setImmediate` et `clearImmediate`).

Si vous passez `"modern"` comme argument, [`@sinonjs/fake-timers`] (https://github.com/sinonjs/fake-timers) sera utilisé comme implémentation au lieu des faux chronomètres de Jest. Cela permet également de se moquer des minuteries supplémentaires comme "Date". Le comportement par défaut de Jest 27 sera "moderne".

Retourne l'objet `jest` pour le chaînage.

### `jest.useRealTimers()`

Donne instruction à Jest d'utiliser les versions réelles des fonctions standard de la minuterie.

Retourne l'objet `jest` pour le chaînage.
### `jest.runAllTicks()`

Evacue la file d'attente des **micro-tâches** (généralement interfacée dans le nœud via `process.nextTick`).

Lorsque cette API est appelée, toutes les micro-tâches en attente qui ont été mises en file d'attente via `process.nextTick` seront exécutées. De plus, si ces micro-tâches programment elles-mêmes de nouvelles micro-tâches, celles-ci seront continuellement épuisées jusqu'à ce qu'il ne reste plus de micro-tâches dans la file d'attente.

### `jest.runAllTimers()`

Evacue à la fois la **macro** file d'attente des tâches (c'est-à-dire toutes les tâches mises en file d'attente par `setTimeout()`, `setInterval()`, et `setImmediate()`) et la **micro** file d'attente des tâches (généralement interfacée dans le nœud  via `process.nextTick`).

Lorsque cette API est appelée, toutes les macro-tâches et micro-tâches en attente seront exécutées. Si ces tâches planifient elles-mêmes de nouvelles tâches, celles-ci seront continuellement épuisées jusqu'à ce qu'il ne reste plus de tâches dans la file d'attente.

Ceci est souvent utile pour exécuter de manière synchrone les setTimeouts pendant un test afin d'affirmer de manière synchrone un certain comportement qui ne se produirait qu'après les rappels `setTimeout()` ou `setInterval()` exécutés. Voir la doc [Timer mocks](TimerMocks.md) pour plus d'informations.

### `jest.runAllImmediates()`

Evacue toutes les tâches mises en file d'attente par `setImmediate()`.

> Note : Cette fonction n'est pas disponible lors de l'utilisation de la mise en œuvre de faux minuteurs modernes

### `jest.advanceTimersByTime(msToRun)`

##### renamed in Jest **22.0.0+**

Aussi sous l'alias : `.runTimersToTime()`

Exécute uniquement la file d'attente des macro-taches (c'est-à-dire toutes les tâches mises en file d'attente par `setTimeout()` ou `setInterval()` et `setImmediate()`).

Lorsque cette API est appelée, tous les temporisateurs sont avancés de `msToRun` millisecondes. Toutes les "macro-tâches" en attente qui ont été mises en file d'attente via `setTimeout()` ou `setInterval()`, et qui seraient exécutées dans ce laps de temps seront exécutées. De plus, si ces macro-tâches prévoient de nouvelles macro-tâches qui seraient exécutées dans le même délai, celles-ci seront exécutées jusqu'à ce qu'il ne reste plus de macro-tâches dans la file d'attente, qui devraient être exécutées dans les "msToRun" millisecondes.

### `jest.runOnlyPendingTimers()`

Exécute uniquement les macro-tâches qui sont actuellement en attente (c'est-à-dire uniquement les tâches qui ont été mises en file d'attente par `setTimeout()` ou `setInterval()` jusqu'à ce point). Si l'une des macro-tâches actuellement en attente prévoit de nouvelles macro-tâches, ces nouvelles tâches ne seront pas exécutées par cet appel.

Ceci est utile pour des scénarios tels que celui où le module testé programme un `setTimeout()` dont le rappel programme un autre `setTimeout()` de manière récursive (ce qui signifie que le programme ne s'arrête jamais). Dans ces scénarios, il est utile de pouvoir avancer dans le temps d'une seule étape à la fois.

### `jest.advanceTimersToNextTimer(steps)`

Avance tous les chronomètres de la milliseconde nécessaire pour que seuls les prochains temps morts/intervalles s'écoulent.

En option, vous pouvez fournir des "étapes", de sorte que le nombre d'étapes des prochains temps morts/intervalles sera exécuté.

### `jest.clearAllTimers()`

Supprime du système de minuterie toute minuterie en attente.

Cela signifie que si des minuteries ont été programmées (mais n'ont pas encore été exécutées), elles seront effacées et n'auront jamais la possibilité d'être exécutées à l'avenir.

### `jest.getTimerCount()`

Renvoie le nombre de fausses minuteries encore en fonctionnement.

### `jest.setSystemTime(now?: number | Date)`

Régler l'heure système actuelle utilisée par les faux minuteurs. Simule un utilisateur qui change l'horloge système pendant que votre programme est en cours d'exécution. Cela affecte l'heure actuelle mais ne provoque pas en soi le déclenchement des minuteurs, par exemple ; ils se déclencheront exactement comme ils l'auraient fait sans l'appel à `jest.setSystemTime()`.

> Note : Cette fonction n'est disponible que si l'on utilise l'implémentation de faux minuteurs modernes

### `jest.getRealSystemTime()`

Lorsque l'on se moque du temps, on se moque aussi de `Date.now()`. Si, pour une raison quelconque, vous avez besoin d'accéder à l'heure actuelle, vous pouvez invoquer cette fonction.

> Note : Cette fonction n'est disponible que si l'on utilise l'implémentation de faux minuteurs modernes

## Divers

### `jest.setTimeout(timeout)`

Définissez l'intervalle de temps par défaut pour les tests et les crochets avant/après en millisecondes. Cela n'affecte que le fichier de test à partir duquel cette fonction est appelée.

_Note : L'intervalle de temps par défaut est de 5 secondes si cette méthode n'est pas appelée._

_Note : Si vous voulez définir le délai d'attente pour tous les fichiers de test, un bon endroit pour le faire est dans `setupFilesAfterEnv`._

Exemple :

```js
jest.setTimeout(1000); // 1 second
```

### `jest.retryTimes()`

Exécute les tests échoués n fois jusqu'à ce qu'ils soient réussis ou jusqu'à ce que le nombre maximum de tentatives soit épuisé. Cela ne fonctionne qu'avec [jest-circus] (https://github.com/facebook/jest/tree/master/packages/jest-circus) !

Exemple dans un test :

```js
jest.retryTimes(3);
test('will fail', () => {
  expect(true).toBe(false);
});
```

Renvoie l'objet `jest` pour l'enchaînement.


# La configuration Jest

La configuration de Jest peut être définie dans le fichier `package.json` de votre projet, ou à travers un fichier `jest.config.js` ou à travers l'option `--config <path/to/file.js|cjs|mjs|json>`. Si vous souhaitez utiliser votre `package.json` pour stocker la configuration de Jest, la touche `"jest"` doit être utilisée au niveau supérieur pour que Jest sache comment trouver vos paramètres :

```json
{
  "name": "my-project",
  "jest": {
    "verbose": true
  }
}
```

Ou par le biais de JavaScript :

```js
// jest.config.js
//Sync object
module.exports = {
  verbose: true,
};

//Or async function
module.exports = async () => {
  return {
    verbose: true,
  };
};
```

Veuillez garder à l'esprit que la configuration résultante doit être compatible avec la série JSON.

Lorsque vous utilisez l'option `--config`, le fichier JSON ne doit pas contenir de clé "jest" :

```json
{
  "bail": 1,
  "verbose": true
}
```

## Options

Ces options vous permettent de contrôler le comportement de Jest dans votre fichier `package.json`. La philosophie de Jest est de fonctionner parfaitement par défaut, mais parfois vous avez juste besoin de plus de puissance de configuration.

### Defaults

Vous pouvez récupérer les options par défaut de Jest pour les développer si nécessaire :

```js
// jest.config.js
const {defaults} = require('jest-config');
module.exports = {
  // ...
  moduleFileExtensions: [...defaults.moduleFileExtensions, 'ts', 'tsx'],
  // ...
};
```

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Reference

### `automock` [boolean]

Par défaut : `false`

Cette option indique à Jest que tous les modules importés dans vos tests doivent être automatiquement simulés. Tous les modules utilisés dans vos tests auront une implémentation de remplacement, en gardant la surface de l'API.

Exemple :

```js
// utils.js
export default {
  authorize: () => {
    return 'token';
  },
  isAuthorized: secret => secret === 'wizard',
};
```

```js
//__tests__/automocking.test.js
import utils from '../utils';

test('if utils mocked automatically', () => {
  // Les méthodes publiques d'"utils" sont désormais des fonctions fictives
  expect(utils.authorize.mock).toBeTruthy();
  expect(utils.isAuthorized.mock).toBeTruthy();

  // Vous pouvez leur fournir votre propre mise en œuvre
  // ou dépasser la valeur de rendement attendue
  utils.authorize.mockReturnValue('mocked_token');
  utils.isAuthorized.mockReturnValue(true);

  expect(utils.authorize()).toBe('mocked_token');
  expect(utils.isAuthorized('not_wizard')).toBeTruthy();
});
```

-Note : les modules de nœuds sont automatiquement simulés lorsque vous avez mis en place une simulation manuelle (par exemple : `__mocks__/lodash.js`). Plus d'informations [ici](manual-mocks.html#mocking-node-modules)._

-Note : Les modules de base, comme `fs`, ne sont pas simulés par défaut. Ils peuvent être moqués explicitement, comme `jest.mock('fs')`._

### `bail` [number | boolean]

Par défaut : `0`

Par défaut, Jest exécute tous les tests et produit toutes les erreurs dans la console à la fin. L'option de configuration de la caution peut être utilisée ici pour que Jest arrête d'exécuter les tests après un échec. Mettre la caution à "true" est identique à mettre la caution à "1".

### `cacheDirectory` [string]

Par défaut : `"/tmp/<path>"`

Le répertoire où Jest doit stocker ses informations de dépendance en cache.

Jest tente d'analyser votre arborescence de dépendances une fois (en amont) et de la mettre en cache afin de faciliter le ratissage du système de fichiers qui doit avoir lieu pendant l'exécution des tests. Cette option de configuration vous permet de personnaliser l'endroit où Jest stocke ces données en cache sur le disque.

### `clearMocks` [boolean]

Par défaut : `false`

Effacer automatiquement les appels et les instances fictifs avant chaque test. Equivalent à appeler `jest.clearAllMocks()` avant chaque test. Cela ne supprime pas les implémentations fictives qui ont pu être fournies.

### `collectCoverage` [boolean]

Par défaut : `false`

Indique si les informations sur la couverture doivent être recueillies pendant l'exécution du test. Étant donné que tous les fichiers exécutés sont équipés de déclarations de collecte de couverture, cela peut ralentir considérablement vos tests.

### `collectCoverageFrom` [array]

Par défaut : `undefined`

Un tableau de [glob patterns] (https://github.com/jonschlinkert/micromatch) indiquant un ensemble de fichiers pour lesquels des informations de couverture doivent être collectées. Si un fichier correspond au modèle de globalité spécifié, les informations de couverture seront collectées pour ce fichier même s'il n'existe aucun test pour ce fichier et qu'il n'est jamais requis dans la suite de tests.

Exemple:

```json
{
  "collectCoverageFrom": [
    "**/*.{js,jsx}",
    "!**/node_modules/**",
    "!**/vendor/**"
  ]
}
```

Cela permettra de recueillir des informations sur la couverture de tous les fichiers contenus dans le "rootDir" du projet, à l'exception de ceux qui correspondent à `**/node_modules/**` ou `**/vendor/**`.

Note : Cette option nécessite que `collectCoverage` soit mis à true ou que Jest soit invoqué avec `--coverage`._

<details>
  <summary>Help:</summary>
  If you are seeing coverage output such as...

```
=============================== Coverage summary ===============================
Statements   : Unknown% ( 0/0 )
Branches     : Unknown% ( 0/0 )
Functions    : Unknown% ( 0/0 )
Lines        : Unknown% ( 0/0 )
================================================================================
Jest: Coverage data for global was not found.
```

Il est très probable que vos modèles de globes ne correspondent à aucun fichier. Consultez la documentation de [micromatch] (https://github.com/jonschlinkert/micromatch) pour vous assurer que vos globes sont compatibles.

</details>

### `coverageDirectory` [string]

Par défaut : `undefined`

Le répertoire où Jest doit produire ses fichiers de couverture.

### `coveragePathIgnorePatterns` [array\<string>]

Par défaut : `["/node_modules/"]`

Un ensemble de chaînes de motifs regexp qui sont comparées à tous les chemins d'accès aux fichiers avant d'exécuter le test. Si le chemin de fichier correspond à l'un des modèles, les informations sur la couverture seront ignorées.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le token de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/", "<répertoire racine>/node_modules/"]`.

### `coverageProvider` [string]

Indique quel fournisseur doit être utilisé pour instrumenter le code pour la couverture. Les valeurs autorisées sont "label" (par défaut) ou "v8".

Notez que l'utilisation de `v8` est considérée comme expérimentale. Il utilise la couverture du code intégré de V8 plutôt qu'un code basé sur Babel. Il n'est pas aussi bien testé, et il a également été amélioré dans les dernières versions de Node. L'utilisation des dernières versions de Node (v14 au moment où nous écrivons ces lignes) donnera de meilleurs résultats.

### `coverageReporters` [array\<string | [string, options]>]

Par défaut : `["json", "lcov", "text", "clover"]`

Une liste de noms de reporter que Jest utilise lors de la rédaction de ses reportages. Tout [reporter d'Istanbul] (https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib) peut être utilisé.

Remarque : le réglage de cette option écrase les valeurs par défaut. Ajoutez `"text"` ou `"text-summary"` pour voir un résumé de la couverture dans la sortie de la console._

Note : Vous pouvez passer des options supplémentaires au reporter d'istanbul en utilisant le formulaire des n-uplets. Par exemple:_
```json
["json", ["lcov", {"projectRoot": "../../"}]]
```

Pour plus d'informations sur la forme de l'objet options, vous pouvez vous référer au type "CoverageReporterWithOptions" dans le [type definitions] (https://github.com/facebook/jest/tree/master/packages/jest-types/src/Config.ts).

### `coverageThreshold` [object]

Par défaut : `undefined`

Cela servira à configurer le seuil minimum d'application pour les résultats de la couverture. Les seuils peuvent être spécifiés comme `global`, comme un [glob] (https://github.com/isaacs/node-glob#glob-primer), et comme un répertoire ou un chemin de fichier. Si les seuils ne sont pas atteints, la plaisanterie échouera. Les seuils spécifiés comme un nombre positif sont considérés comme étant le pourcentage minimum requis. Les seuils spécifiés comme un nombre négatif représentent le nombre maximum d'entités non couvertes autorisé.

Par exemple, avec la configuration suivante, jest échouera s'il y a moins de 80 % de branches, lignes et fonctions couvertes, ou s'il y a plus de 10 déclarations non couvertes :

```json
{
  ...
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": -10
      }
    }
  }
}
```

Si des globes ou des chemins sont spécifiés à côté de `global`, les données de couverture pour les chemins correspondants seront soustraites de la couverture globale et les seuils seront appliqués indépendamment. Les seuils pour les globs sont appliqués à tous les fichiers correspondant au global. Si le fichier spécifié par le chemin n'est pas trouvé, une erreur est renvoyée.

Par exemple, avec la configuration suivante :

```json
{
  ...
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 50,
        "functions": 50,
        "lines": 50,
        "statements": 50
      },
      "./src/components/": {
        "branches": 40,
        "statements": 40
      },
      "./src/reducers/**/*.js": {
        "statements": 90
      },
      "./src/api/very-important-module.js": {
        "branches": 100,
        "functions": 100,
        "lines": 100,
        "statements": 100
      }
    }
  }
}
```

Jest échouera si :

- Le répertoire `./src/components` a moins de 40% de couverture de branches ou d'énoncés.
- Un des fichiers correspondant au répertoire `./src/reducers/**/*.js` glob a une couverture de moins de 90%.
- Le fichier `./src/api/very-important-module.js` a une couverture inférieure à 100%.
- Tous les autres fichiers combinés ont une couverture inférieure à 50 % (`global`).

### `dependencyExtractor` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un extracteur de dépendance personnalisé. Il doit s'agir d'un module de noeud qui exporte un objet avec une fonction `extraire`. Par exemple :

```javascript
const fs = require('fs');
const crypto = require('crypto');

module.exports = {
  extract(code, filePath, defaultExtract) {
    const deps = defaultExtract(code, filePath);
    // Scanner le fichier et ajouter des dépendances dans `deps` (qui est un `Set`)
    return deps;
  },
  getCacheKey() {
    return crypto
      .createHash('md5')
      .update(fs.readFileSync(__filename))
      .digest('hex');
  },
};
```

La fonction `extract` devrait retourner un itérable (`Array`, `Set`, etc.) avec les dépendances trouvées dans le code.

Ce module peut également contenir une fonction `getCacheKey` pour générer une clé de cache afin de déterminer si la logique a changé et si les artefacts de cache qui en dépendent doivent être éliminés.

### `displayName` [string, object]

Par défaut : `undefined`

Permet d'imprimer une étiquette à côté d'un test en cours d'exécution. Cela devient plus utile dans les dépôts multi-projets où il peut y avoir de nombreux fichiers de configuration de blagues. Cela permet de savoir visuellement à quel projet appartient un test. Voici des exemples de valeurs valides.

```js
module.exports = {
  displayName: 'CLIENT',
};
```

ou

```js
module.exports = {
  displayName: {
    name: 'CLIENT',
    color: 'blue',
  },
};
```

Comme option secondaire, un objet avec les propriétés `name` et `color` peut être passé. Cela permet une configuration personnalisée de la couleur de fond du displayName. Par défaut, `displayName` est blanc lorsque sa valeur est une chaîne de caractères. Jest utilise [chalk](https://github.com/chalk/chalk) pour fournir la couleur. Ainsi, toutes les options valides pour les couleurs supportées par la craie sont également supportées par jest.

### `errorOnDeprecated` [boolean]

Par défaut : `false`

Faite en sorte que les API obsolètes envoient des messages d'erreur utiles. Utile pour faciliter le processus de mise à niveau.

### `extraGlobals` [array\<string>]

Par défaut : `undefined`

Les fichiers de test s'exécutent dans un [vm](https://nodejs.org/api/vm.html), qui ralentit les appels aux propriétés du contexte global (par exemple `Math`). Avec cette option, vous pouvez spécifier des propriétés supplémentaires à définir à l'intérieur du vm pour des recherches plus rapides.

Par exemple, si vos tests appellent souvent `Math`, vous pouvez le passer en définissant `extraGlobals`.

```json
{
  ...
  "jest": {
    "extraGlobals": ["Math"]
  }
}
```

### `forceCoverageMatch` [array\<string>]

Par défaut : `['']`

Les fichiers de test sont normalement ignorés lors de la collecte de la couverture de code. Avec cette option, vous pouvez écraser ce comportement et inclure les fichiers autrement ignorés dans la couverture de code.

Par exemple, si vous avez des tests dans des fichiers sources nommés avec l'extension `.t.js` comme suit :

```javascript
// sum.t.js

export function sum(a, b) {
  return a + b;
}

if (process.env.NODE_ENV === 'test') {
  test('sum', () => {
    expect(sum(1, 2)).toBe(3);
  });
}
```

Vous pouvez collecter la couverture de ces fichiers avec le paramètre `forceCoverageMatch`.

```json
{
  ...
  "jest": {
    "forceCoverageMatch": ["**/*.t.js"]
  }
}
```

### `globals` [object]

Par défaut : `{}`

Un ensemble de variables globales qui doivent être disponibles dans tous les environnements de test.

Par exemple, ce qui suit créerait une variable globale `__DEV__` définie comme `vrai` dans tous les environnements de test :

```json
{
  ...
  "jest": {
    "globals": {
      "__DEV__": true
    }
  }
}
```

Notez que, si vous spécifiez une valeur de référence globale (comme un objet ou un tableau) ici, et que certains codes mutent cette valeur au milieu de l'exécution d'un test, cette mutation ne sera _pas_ persistante d'une exécution à l'autre pour les autres fichiers de test. De plus, l'objet `global` doit être sérialisable en json, il ne peut donc pas être utilisé pour spécifier des fonctions globales. Pour cela, vous devez utiliser les `setupFiles`.

### `globalSetup` [string]

Par défaut : `undefined`

Cette option permet d'utiliser un module de configuration globale personnalisé qui exporte une fonction asynchrone qui est déclenchée une fois avant toutes les suites de tests. Cette fonction reçoit l'objet "GlobalConfig" de Jest comme paramètre.

Note : Un module de configuration globale configuré dans un projet (utilisant un runner multi-projets) ne sera déclenché que si vous exécutez au moins un test de ce projet.

Note : Toutes les variables globales qui sont définies par `globalSetup` ne peuvent être lues que dans `globalTeardown`. Vous ne pouvez pas récupérer les variables globales définies ici dans vos suites de test.

Note : Alors que la transformation de code est appliquée au fichier de configuration lié, Jest ne transformera **pas** de code dans les `node_modules`. Ceci est dû à la nécessité de charger les transformateurs réels (par exemple `babel` ou `typescript`) pour effectuer la transformation._

Exemple:

```js
// setup.js
module.exports = async () => {
  // ...
  // Mettre la référence à mongod afin de fermer le serveur pendant le démontage.
  global.__MONGOD__ = mongod;
};
```

```js
// teardown.js
module.exports = async function () {
  await global.__MONGOD__.stop();
};
```

### `globalTeardown` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un module de démontage global personnalisé qui exporte une fonction d'asynchronisation qui est déclenchée une fois après toutes les suites de tests. Cette fonction reçoit l'objet "GlobalConfig" de Jest comme paramètre.

Note : Un module de démontage global configuré dans un projet (utilisant un runner multi-projets) ne sera déclenché que si vous exécutez au moins un test à partir de ce projet.

Note : La même mise en garde concernant la transformation des `node_modules` que pour `globalSetup` s'applique à `globalTeardown`._

### `maxConcurrency` [number]

Par défaut : `5`

Un nombre limitant le nombre de tests autorisés à être exécutés en même temps lors de l'utilisation de `test.concurrent`. Tout test dépassant cette limite sera mis en file d'attente et exécuté une fois qu'un créneau est libéré.

### `moduleDirectories` [array\<string>]

Par défaut : `["node_modules"]`

Un tableau de noms de répertoires à rechercher récursivement vers le haut à partir de l'emplacement du module requis. Le réglage de cette option _remplace_ la valeur par défaut, si vous souhaitez toujours rechercher des `node_modules` pour les paquets l'incluent avec toute autre option : ["node_modules", "bower_components"].

### `moduleFileExtensions` [array\<string>]

Par défaut : `["js", "json", "jsx", "ts", "tsx", "node"]`

Une série d'extensions de fichiers que vos modules utilisent. Si vous avez besoin de modules sans spécifier d'extension de fichier, voici les extensions que Jest recherchera, dans l'ordre de gauche à droite.

Nous vous recommandons de placer les extensions les plus couramment utilisées dans votre projet sur la gauche, donc si vous utilisez le TypeScript, vous pouvez envisager de déplacer "ts" et/ou "tsx" au début du tableau.

### `moduleNameMapper` [object\<string, string | array\<string>>]

Default: `null`

Une carte allant des expressions régulières aux noms de modules ou aux tableaux de noms de modules qui permettent de tronquer des ressources, comme des images ou des styles, avec un seul module.

Les modules qui sont mappés à un alias sont démotivés par défaut, que l'auto-modélisation soit activée ou non.

Utilisez le conteneur de chaîne `<rootDir>` pour faire référence à la valeur de [`rootDir`](#rootdir-string) si vous voulez utiliser des chemins de fichiers.

De plus, vous pouvez substituer les groupes de regex capturés en utilisant des références numérotées.

Exemple:

```json
{
  "moduleNameMapper": {
    "^image![a-zA-Z0-9$_-]+$": "GlobalImageStub",
    "^[./a-zA-Z0-9$_-]+\\.png$": "<rootDir>/RelativeImageStub.js",
    "module_name_(.*)": "<rootDir>/substituted_module_$1.js",
    "assets/(.*)": [
      "<rootDir>/images/$1",
      "<rootDir>/photos/$1",
      "<rootDir>/recipes/$1"
    ]
  }
}
```

L'ordre dans lequel les cartographies sont définies est important. Les modèles sont vérifiés un par un jusqu'à ce que l'un d'entre eux corresponde. La règle la plus spécifique doit être mentionnée en premier. Ceci est également vrai pour les tableaux de noms de modules.

Note : Si vous fournissez un nom de module sans limites, cela peut causer des erreurs difficiles à repérer. Par exemple, `relay` remplacera tous les modules qui contiennent `relay` comme sous-chaîne dans leur nom : `relay`, `react-relay` et `graphql-relay` seront tous dirigés vers votre talon.

### `modulePathIgnorePatterns` [array\<string>]

Par défaut : `[]`

Un tableau de chaînes de motifs regexp qui sont comparées à tous les chemins de module avant que ces chemins ne soient considérés comme "visibles" pour le chargeur de module. Si le chemin d'un module donné correspond à l'un des motifs, il ne sera pas `require()`able dans l'environnement de test.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/"]`.

### `modulePaths` [array\<string>]

Par défaut : `[]`

Une API alternative au paramétrage de la variable `NODE_PATH` env, `modulePaths` est un tableau de chemins absolus vers des emplacements supplémentaires à rechercher lors de la résolution de modules. Utilisez le token de chaîne `<rootDir>` pour inclure le chemin vers le répertoire racine de votre projet. Exemple : `["<rootDir>/app/"]`.

### `notify` [boolean]

Par défaut : `false`

Active les notifications des résultats des tests.

**Attention : Jest utilise [node-notifier] (https://github.com/mikaelbr/node-notifier) pour afficher les notifications sur le bureau. Sous Windows, il crée une nouvelle entrée dans le menu de démarrage lors de la première utilisation et n'affiche pas la notification. Les notifications seront correctement affichées lors des exécutions suivantes.

### `notifyMode` [string]

Par défaut : `failure-change`

Précise le mode de notification. Requiert "notify : true".

#### Modes

- `always`: toujours envoyer une notification.
- `failure`: envoie une notificqtion lorsque les tests échouent
- `success`: envoie une notification lorsque les tests réussissent.
- `change`: envoie une notification quans le status à changé.
- `success-change`: envoie une notification quans les tests réussissent ou une fois quand ils échouent.
- `failure-change`: envoie une notification quand les tests échouent ou une fois lorsqu'il réussissent.

### `preset` [string]

Par défaut : `undefined`

Un préréglage qui sert de base à la configuration de Jest. Un preset doit pointer vers un module npm qui a un fichier `jest-preset.json` ou `jest-preset.js` à la racine.

Par exemple, ce preset `foo-bar/jest-preset.js` sera configuré comme suit :

```json
{
  "preset": "foo-bar"
}
```

Les préréglages peuvent également être relatifs aux chemins du système de fichiers.

```json
{
  "preset": "./node_modules/foo-bar/jest-preset.js"
}
```

### `prettierPath` [string]

Par défaut : `'prettier'`

Définit le chemin d'accès au module du nœud [`prettier`](https://prettier.io/) utilisé pour mettre à jour les instantanés en ligne.

### `projects` [array\<string | ProjectConfig>]

Par defaut : `undefined`

Lorsque la configuration des "projets" est fournie avec un tableau de chemins ou de modèles de globes, Jest effectuera des tests dans tous les projets spécifiés en même temps. C'est idéal pour les monorepos ou lorsque l'on travaille sur plusieurs projets en même temps.

```json
{
  "projects": ["<rootDir>", "<rootDir>/examples/*"]
}
```

Cette configuration d'exemple exécutera Jest dans le répertoire racine ainsi que dans chaque dossier du répertoire exemples. Vous pouvez avoir un nombre illimité de projets en cours d'exécution dans la même instance de Jest.

La fonction projets peut également être utilisée pour exécuter plusieurs configurations ou plusieurs [runners](#runner-string). Pour cela, vous pouvez passer un tableau d'objets de configuration. Par exemple, pour exécuter à la fois des tests et ESLint (via [jest-runner-eslint](https://github.com/jest-community/jest-runner-eslint)) dans la même invocation de Jest :

```json
{
  "projects": [
    {
      "displayName": "test"
    },
    {
      "displayName": "lint",
      "runner": "jest-runner-eslint",
      "testMatch": ["<rootDir>/**/*.js"]
    }
  ]
}
```

Note : Lorsque vous utilisez un runner multi-projets, il est recommandé d'ajouter un `displayName` pour chaque projet. Cela affichera le `displayName` d'un projet à côté de ses tests._

### `reporters` [array\<moduleName | [moduleName, options]>]

Par défaut : `undefined`

Utilisez cette option de configuration pour ajouter des reporters personnalisés à Jest. Un rapporteur personnalisé est une classe qui implémente les méthodes `onRunStart`, `onTestStart`, `onTestResult`, `onRunComplete` qui seront appelées lorsque l'un de ces événements se produira.

Si des reporters personnalisés sont spécifiés, les reporters Jest par défaut seront remplacés. Pour conserver les rapporteurs par défaut, `default` peut être passé comme nom de module.

Ceci remplacera les rapporteurs par défaut :

```json
{
  "reporters": ["<rootDir>/my-custom-reporter.js"]
}
```

Ce système utilisera un rapporteur personnalisé en plus des rapporteurs par défaut que Jest fournit :

```json
{
  "reporters": ["default", "<rootDir>/my-custom-reporter.js"]
}
```

De plus, les rapporteurs personnalisés peuvent être configurés en passant un objet "options" comme second argument :

```json
{
  "reporters": [
    "default",
    ["<rootDir>/my-custom-reporter.js", {"banana": "yes", "pineapple": "no"}]
  ]
}
```

Les modules reporters personnalisés doivent définir une classe qui prend un `GlobalConfig` et des options reporters comme arguments de construction :

Exemple de rapporteur :

```js
// my-custom-reporter.js
class MyCustomReporter {
  constructor(globalConfig, options) {
    this._globalConfig = globalConfig;
    this._options = options;
  }

  onRunComplete(contexts, results) {
    console.log('Custom reporter output:');
    console.log('GlobalConfig: ', this._globalConfig);
    console.log('Options: ', this._options);
  }
}

module.exports = MyCustomReporter;
// or export default MyCustomReporter;
```

Les reporters personnalisés peuvent également forcer Jest à sortir avec un code non-0 en retournant une erreur des méthodes `getLastError()`.

```js
class MyCustomReporter {
  // ...
  getLastError() {
    if (this._shouldFail) {
      return new Error('my-custom-reporter.js reported an error');
    }
  }
}
```

Pour la liste complète des méthodes et des types d'arguments, voir l'interface `Reporter` dans [packages/jest-reporters/src/types.ts](https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts)

### `resetMocks` [boolean]

Par défaut : `false`

Réinitialisation automatique de l'état simulé avant chaque test. Equivalent à appeler `jest.resetAllMocks()` avant chaque test. Cela conduit à la suppression des fausses implémentations de tous les mocks, mais ne rétablit pas leur implémentation initiale.

### `resetModules` [boolean]

Par défaut : `false`

Par défaut, chaque fichier de test reçoit son propre registre de module indépendant. L'activation de `resetModules` va plus loin et réinitialise le registre de module avant de lancer chaque test individuel. Ceci est utile pour isoler les modules pour chaque test afin que l'état local du module ne soit pas en conflit entre les tests. Cela peut être fait par programmation en utilisant [`jest.resetModules()`](JestObjectAPI.md#jestresetmodules).

### `resolver` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un résolveur personnalisé. Ce résolveur doit être un module de noeud qui exporte une fonction en attendant une chaîne de caractères comme premier argument pour le chemin à résoudre et un objet avec la structure suivante comme deuxième argument :

```json
{
  "basedir": string,
  "defaultResolver": "function(request, options)",
  "extensions": [string],
  "moduleDirectory": [string],
  "paths": [string],
  "packageFilter": "function(pkg, pkgdir)",
  "rootDir": [string]
}
```

La fonction doit soit renvoyer un chemin d'accès au module qui doit être résolu, soit lancer une erreur si le module ne peut être trouvé.

Note : le résolveur par défaut passé en option est le résolveur par défaut Jest qui peut être utile lorsque vous écrivez votre propre résolution. Il prend les mêmes arguments que votre résolution personnalisée, par exemple `(request, options)`.

Par exemple, si vous voulez respecter le champ [``navigateur`` de Browserify](https://github.com/browserify/browserify-handbook/blob/master/readme.markdown#browser-field), vous pouvez utiliser la configuration suivante :

```json
{
  ...
  "jest": {
    "resolver": "browser-resolve"
  }
}
```

En combinant `defaultResolver` et `packageFilter`, nous pouvons implémenter un `package.json` "pré-processeur" qui nous permet de changer la façon dont le résolveur par défaut résoudra les modules. Par exemple, imaginez que nous voulions utiliser le champ `"module"` s'il est présent, sinon, revenez à `"main"` :

```json
{
  ...
  "jest": {
    "resolver": "my-module-resolve"
  }
}
```

```js
// my-module-resolve package

module.exports = (request, options) => {
  // Appeler le defaultResolver, afin d'exploiter son cache, la gestion des erreurs, etc.
  return options.defaultResolver(request, {
    ...options,
    // Utiliser packageFilter pour traiter le `package.json` analysé avant la résolution (voir https://www.npmjs.com/package/resolve#resolveid-opts-cb)
    packageFilter: pkg => {
      return {
        ...pkg,
        // Modifier la valeur de "main" avant de résoudre le paquet
        main: pkg.module || pkg.main,
      };
    },
  });
};
```

### `restoreMocks` [boolean]

Par défaut : `false`

Restaurer automatiquement l'état de simulation avant chaque test. Equivalent à appeler `jest.restoreAllMocks()` avant chaque test. Cela permet de supprimer les fausses implémentations de tous les mocks et de restaurer leur implémentation initiale.

### `rootDir` [string]

Par défaut : La racine du répertoire contenant votre Jest [fichier de configuration](#) _ou_ le `package.json` _ou_ le [`pwd`](http://en.wikipedia.org/wiki/Pwd) si aucun `package.json` n'est trouvé

Le répertoire racine que Jest doit analyser pour les tests et les modules qui s'y trouvent. Si vous mettez votre configuration Jest dans votre `package.json` et que vous voulez que le répertoire racine soit la racine de votre repo, la valeur de ce paramètre de configuration sera par défaut le répertoire du `package.json`.

Souvent, vous voudrez mettre ce paramètre à `src'` ou `'lib'`, correspondant à l'endroit où le code est stocké dans votre dépôt.

_Notez que l'utilisation de `'<rootDir>'` comme chaîne de caractères dans tout autre paramètre de configuration basé sur le chemin d'accès fera référence à cette valeur. Ainsi, par exemple, si vous voulez que votre entrée de configuration [`setupFiles`](#setupfiles-array) pointe sur le fichier `env-setup.js` à la racine de votre projet, vous pouvez définir sa valeur à `["<rootDir>/env-setup.js"]`._

### `roots` [array\<string>]

Par défaut : `["<rootDir>"]`

Une liste de chemins d'accès aux répertoires que Jest doit utiliser pour rechercher des fichiers dans.

Il peut arriver que vous vouliez que Jest ne cherche que dans un seul sous-répertoire (par exemple, si vous avez un répertoire "src/" dans votre repo), mais que vous l'empêchiez d'accéder au reste du repo.

_Note : Alors que `rootDir` est principalement utilisé comme un jeton à réutiliser dans d'autres options de configuration, `roots` est utilisé par les internes de Jest pour localiser les **fichiers de test et les fichiers sources**. Cela s'applique également à la recherche de modules manuels pour les modules de `node_modules` (`__mocks__` devront vivre dans une des `roots`)._

_Note : Par défaut, `roots` a une seule entrée `<rootDir>` mais il y a des cas où vous pouvez vouloir avoir plusieurs racines dans un même projet, par exemple `roots : ["<rootDir>/src/", "<rootDir>/tests/"]`._

### `runner` [string]

Par défaut : `"jest-runner"`

Cette option vous permet d'utiliser un runner personnalisé au lieu du runner de test par défaut de Jest. Voici quelques exemples de runners :

- [`jest-runner-eslint`](https://github.com/jest-community/jest-runner-eslint)
- [`jest-runner-mocha`](https://github.com/rogeliog/jest-runner-mocha)
- [`jest-runner-tsc`](https://github.com/azz/jest-runner-tsc)
- [`jest-runner-prettier`](https://github.com/keplersj/jest-runner-prettier)

_Note : La valeur de la propriété "runner" peut omettre le préfixe "jest-runner-" du nom du paquet._

Pour écrire un test-runner, exportez une classe qui accepte `globalConfig` dans le constructeur, et qui a une méthode `runTests` avec la signature :

```ts
async runTests(
  tests: Array<Test>,
  watcher: TestWatcher,
  onStart: OnTestStart,
  onResult: OnTestSuccess,
  onFailure: OnTestFailure,
  options: TestRunnerOptions,
): Promise<void>
```

Si vous avez besoin de limiter votre test-runner à fonctionner en série plutôt qu'en parallèle, votre classe doit avoir la propriété `isSerial` pour être définie comme `true`.

### `setupFiles` [array]

Par défaut : `[]`

Une liste de chemins d'accès aux modules qui exécutent du code pour configurer ou mettre en place l'environnement de test. Chaque setupFile sera exécuté une fois par fichier de test. Comme chaque test s'exécute dans son propre environnement, ces scripts seront exécutés dans l'environnement de test immédiatement avant l'exécution du code de test lui-même.

Il est également intéressant de noter que les `setupFiles` s'exécuteront _avant_ [`setupFilesAfterEnv`](#setupfilesafterenv-array).

### `setupFilesAfterEnv` [array]

Default: `[]`

Une liste de chemins d'accès aux modules qui exécutent du code pour configurer ou mettre en place le cadre de test avant que chaque fichier de test de la suite ne soit exécuté. Puisque [`setupFiles`](#setupfiles-array) s'exécute avant que le cadre de test soit installé dans l'environnement, ce fichier de script vous offre la possibilité d'exécuter du code immédiatement après l'installation du cadre de test dans l'environnement.

Si vous voulez qu'un chemin soit [relatif au répertoire racine de votre projet](#rootdir-string), veuillez inclure `<rootDir>` dans une chaîne de chemin, comme `"<rootDir>/a-configs-folder"`.

Par exemple, Jest est livré avec plusieurs plug-ins pour "jasmine" qui fonctionnent en patchant l'API de jasmine. Si vous souhaitez ajouter encore plus de plugins jasmin au mélange (ou si vous voulez des matchers personnalisés pour l'ensemble du projet par exemple), vous pouvez le faire dans ces modules.

-Note : `setupTestFrameworkScriptFile` est déprécié en faveur de `setupFilesAfterEnv`._

Exemple `setupFilesAfterEnv` un tableau dans un jest.config.js:

```js
module.exports = {
  setupFilesAfterEnv: ['./jest.setup.js'],
};
```

Exemple le fichier `jest.setup.js`

```js
jest.setTimeout(10000); // in milliseconds
```

### `slowTestThreshold` [number]

Par défaut : `5`

Le nombre de secondes après lequel un test est considéré comme lent et signalé comme tel dans les résultats.

### `snapshotResolver` [string]

Par défaut : `undefined`

Le chemin vers un module qui peut résoudre le chemin test<->snapshot. Cette option de configuration vous permet de personnaliser l'endroit où Jest stocke les fichiers d'instantanés sur le disque.

Exemple de module de résolution d'instantanés :

```js
module.exports = {
  // passe du test à l'instantané
  resolveSnapshotPath: (testPath, snapshotExtension) =>
    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,

  // se résout de l'instantané à la voie de test
  resolveTestPath: (snapshotFilePath, snapshotExtension) =>
    snapshotFilePath
      .replace('__snapshots__', '__tests__')
      .slice(0, -snapshotExtension.length),

  // Exemple de parcours de test, utilisé pour le contrôle de cohérence avant vol de la mise en œuvre ci-dessus
  testPathForConsistencyCheck: 'some/__tests__/example.test.js',
};
```

### `snapshotSerializers` [array\<string>]

Par défaut : `[]`

Une liste de chemins d'accès aux modules de sérialisation des instantanés que Jest devrait utiliser pour les tests d'instantanés.

Jest dispose de sérialiseurs par défaut pour les types JavaScript intégrés, les éléments HTML (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) et pour les éléments React. Voir le [tutoriel de test instantané] (TutorialReactNative.md#snapshot-test) pour plus d'informations.

Exemple de module de sérialisation :

```js
// my-serializer-module
module.exports = {
  serialize(val, config, indentation, depth, refs, printer) {
    return 'Pretty foo: ' + printer(val.foo);
  },

  test(val) {
    return val && val.hasOwnProperty('foo');
  },
};
```

`printer` est une fonction qui sérialise une valeur en utilisant des plugins existants.

Pour utiliser `my-serializer-module` comme sérialiseur, la configuration serait la suivante :

```json
{
  ...
  "jest": {
    "snapshotSerializers": ["my-serializer-module"]
  }
}
```

Enfin, les tests se présenteraient comme suit :

```js
test(() => {
  const bar = {
    foo: {
      x: 1,
      y: 2,
    },
  };

  expect(bar).toMatchSnapshot();
});
```

Rendu instantané :

```json
Pretty foo: Object {
  "x": 1,
  "y": 2,
}
```

Pour rendre une dépendance explicite plutôt qu'implicite, vous pouvez appeler [`expect.addSnapshotSerializer`](ExpectAPI.md#expectaddsnapshotserializerserializer) pour ajouter un module pour un fichier de test individuel au lieu d'ajouter son chemin vers `snapshotSerializers` dans la configuration de Jest.

Pour en savoir plus sur l'API des sérialiseurs, voir [ici] (https://github.com/facebook/jest/tree/master/packages/pretty-format/README.md#serialize).

### `testEnvironment` [string]

Par défaut : `"jsdom"`

L'environnement de test qui sera utilisé pour les essais. L'environnement par défaut de Jest est un environnement de type navigateur via [jsdom] (https://github.com/jsdom/jsdom). Si vous construisez un service de noeud, vous pouvez utiliser l'option "node" pour utiliser un environnement de type noeud à la place.

En ajoutant un bloc de documentation "@jest environment" en haut du fichier, vous pouvez spécifier un autre environnement à utiliser pour tous les tests dans ce fichier :

```js
/**
 * @jest-environment jsdom
 */

test('use jsdom in this test file', () => {
  const element = document.createElement('div');
  expect(element).not.toBeNull();
});
```

Vous pouvez créer votre propre module qui sera utilisé pour mettre en place l'environnement de test. Le module doit exporter une classe avec les méthodes `setup`, `teardown` et `runScript`. Vous pouvez également passer des variables de ce module à vos suites de test en les assignant à l'objet `this.global` &ndash ; cela les rendra disponibles dans vos suites de test en tant que variables globales.

La classe peut éventuellement exposer une méthode asynchrone `handleTestEvent` pour se lier aux événements déclenchés par [`jest-circus`](https://github.com/facebook/jest/tree/master/packages/jest-circus). Normalement, le testeur de `jest-circus` ferait une pause jusqu'à ce qu'une promesse retournée par `handleTestEvent` soit remplie, **sauf pour les prochains événements** : `start_describe_definition`, `finish_describe_definition`, `add_hook`, `add_test` ou `error` (pour la liste à jour, vous pouvez consulter [SyncEvent type in the types definitions](https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts)). Cela est dû à des raisons de rétrocompatibilité et à la signature `process.on('unhandledRejection', callback)`, mais cela ne devrait généralement pas poser de problème dans la plupart des cas d'utilisation.

Tout pragmatisme de docblock dans les fichiers de test sera transmis au constructeur d'environnement et peut être utilisé pour la configuration par test. Si le pragmatisme n'a pas de valeur, il sera présent dans l'objet avec sa valeur fixée à une chaîne vide. Si le pragmatisme n'est pas présent, il ne sera pas présent dans l'objet.

_Note : TestEnvironment est un environnement "sandboxed". Chaque suite de test déclenchera la configuration/le démontage dans son propre TestEnvironment._

Exemple :

```js
// my-custom-environment
const NodeEnvironment = require('jest-environment-node');

class CustomEnvironment extends NodeEnvironment {
  constructor(config, context) {
    super(config, context);
    this.testPath = context.testPath;
    this.docblockPragmas = context.docblockPragmas;
  }

  async setup() {
    await super.setup();
    await someSetupTasks(this.testPath);
    this.global.someGlobalObject = createGlobalObject();

    // Will trigger if docblock contains @my-custom-pragma my-pragma-value
    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {
      // ...
    }
  }

  async teardown() {
    this.global.someGlobalObject = destroyGlobalObject();
    await someTeardownTasks();
    await super.teardown();
  }

  runScript(script) {
    return super.runScript(script);
  }

  async handleTestEvent(event, state) {
    if (event.name === 'test_start') {
      // ...
    }
  }
}

module.exports = CustomEnvironment;
```

```js
// my-test-suite
let someGlobalObject;

beforeAll(() => {
  someGlobalObject = global.someGlobalObject;
});
```

### `testEnvironmentOptions` [Object]

Par défaut : `{}`

Les options d'environnement de test qui seront transmises au "TestEnvironment". Les options pertinentes dépendent de l'environnement. Par exemple, vous pouvez remplacer les options données à [jsdom](https://github.com/jsdom/jsdom) telles que `{userAgent : "Agent/007"}`.

### `testMatch` [array\<string>]

(par défaut : "**/__tests__/**/*.[jt]s ?(x)", "**/ ?(*.)+(spec|test).[jt]s ?(x)") ]`)

Les modèles de globes que Jest utilise pour détecter les fichiers de test. Par défaut, il recherche les fichiers `.js`, `.jsx`, `.ts` et `.tsx` à l'intérieur des dossiers `__tests__`, ainsi que tout fichier portant le suffixe `.test` ou `.spec` (par exemple `Component.test.js` ou `Component.spec.js`). Il trouvera également des fichiers appelés `test.js` ou `spec.js`.

Voir le paquet [micromatch] (https://github.com/jonschlinkert/micromatch) pour plus de détails sur les modèles que vous pouvez spécifier.

Voir aussi [`testRegex` [string | array\<string>]](#testregex-string--arraystring), mais notez que vous ne pouvez pas spécifier les deux options.

### `testPathIgnorePatterns` [array\<string>]

Par défaut : `["/node_modules/"]`

Un tableau d'ensemble de chaînes regexp qui sont comparées à tous les chemins de test avant l'exécution du test. Si le chemin de test correspond à l'un des modèles, il sera ignoré.

Ces chaînes de motifs correspondent au chemin complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/build/", "<répertoire racine>/node_modules/"]`.

### `testRegex` [string | array\<string>]

Par défaut : `(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$`

Le ou les modèles que Jest utilise pour détecter les fichiers tests. Par défaut, il recherche les fichiers `.js`, `.jsx`, `.ts` et `.tsx` à l'intérieur des dossiers `__tests__`, ainsi que tout fichier portant le suffixe `.test` ou `.spec` (par exemple `Component.test.js` ou `Component.spec.js`). Il trouvera également des fichiers appelés `test.js` ou `spec.js`. Voir aussi [`testMatch` [array\<string>]](#testmatch-arraystring), mais notez que vous ne pouvez pas spécifier les deux options.

Ce qui suit est une visualisation de la regex par défaut :

```bash
├── __tests__
│   └── component.spec.js # test
│   └── anything # test
├── package.json # not test
├── foo.test.js # test
├── bar.spec.jsx # test
└── component.js # not test
```

_Note : `testRegex` essaiera de détecter les fichiers de test en utilisant le **chemin de fichier absolu**, par conséquent, avoir un dossier avec un nom qui correspond lancera tous les fichiers comme tests_.

### `testResultsProcessor` [string]

Par défaut : `undefined`

Cette option permet l'utilisation d'un processeur de résultats personnalisé. Ce processeur doit être un module de nœud qui exporte une fonction en attendant un objet ayant la structure suivante comme premier argument et le renvoie :

```json
{
  "success": bool,
  "startTime": epoch,
  "numTotalTestSuites": number,
  "numPassedTestSuites": number,
  "numFailedTestSuites": number,
  "numRuntimeErrorTestSuites": number,
  "numTotalTests": number,
  "numPassedTests": number,
  "numFailedTests": number,
  "numPendingTests": number,
  "numTodoTests": number,
  "openHandles": Array<Error>,
  "testResults": [{
    "numFailingTests": number,
    "numPassingTests": number,
    "numPendingTests": number,
    "testResults": [{
      "title": string (message in it block),
      "status": "failed" | "pending" | "passed",
      "ancestorTitles": [string (message in describe blocks)],
      "failureMessages": [string],
      "numPassingAsserts": number,
      "location": {
        "column": number,
        "line": number
      }
    },
    ...
    ],
    "perfStats": {
      "start": epoch,
      "end": epoch
    },
    "testFilePath": absolute path to test file,
    "coverage": {}
  },
  ...
  ]
}
```

### `testRunner` [string]

Par défaut : `jasmine2`

Cette option permet l'utilisation d'un testeur personnalisé. La valeur par défaut est jasmine2. Un programme de test personnalisé peut être fourni en spécifiant un chemin d'accès à une implémentation de programme de test.

Le module de l'exécuteur de test doit exporter une fonction avec la signature suivante :

```ts
function testRunner(
  globalConfig: GlobalConfig,
  config: ProjectConfig,
  environment: Environment,
  runtime: Runtime,
  testPath: string,
): Promise<TestResult>;
```

Un exemple de cette fonction se trouve dans notre [paquet de test jasmine2] par défaut (https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts).


### `testSequencer` [string]

Par défaut : `@jest/test-sequencer`

Cette option vous permet d'utiliser un séquenceur personnalisé au lieu du séquenceur par défaut de Jest. L'option `sort` peut éventuellement retourner une Promesse.

Exemple :

Trier le chemin de test par ordre alphabétique.

```js
// testSequencer.js
const Sequencer = require('@jest/test-sequencer').default;

class CustomSequencer extends Sequencer {
  sort(tests) {
    // Informations sur la structure d'essai
    // https://github.com/facebook/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21
    const copyTests = Array.from(tests);
    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));
  }
}

module.exports = CustomSequencer;
```

Utilisez-le dans votre fichier de configuration Jest comme ceci :

```json
{
  "testSequencer": "path/to/testSequencer.js"
}
```

### `testTimeout` [number]

Par défaut : `5000`

Délai d'attente par défaut d'un test en millisecondes.

### `testURL` [string]

Par défaut : `http://localhost`

Cette option permet de définir l'URL de l'environnement jsdom. Elle se reflète dans des propriétés telles que "location.href".

### `timers` [string]

Par défaut : `real`

Le réglage de cette valeur à `legacy` ou `fake` permet l'utilisation de faux minuteurs pour des fonctions telles que `setTimeout`. Les faux timers sont utiles lorsqu'un morceau de code fixe un long délai d'attente que nous ne voulons pas attendre dans un test.

Si la valeur est `modern`, [`@sinonjs/fake-timers`] (https://github.com/sinonjs/fake-timers) sera utilisé comme implémentation au lieu de l'implémentation de Jest. Ce sera la fausse implémentation par défaut dans Jest 27.

### `transform` [object\<string, pathToTransformer | [pathToTransformer, object]>]

Par défaut : `{"^.+\\.[jt]sx?$": "babel-jest"}`

Une carte qui va des expressions régulières aux chemins des transformateurs. Un transformateur est un module qui fournit une fonction synchrone pour transformer les fichiers sources. Par exemple, si vous voulez pouvoir utiliser une nouvelle fonction de langage dans vos modules ou tests qui ne sont pas encore pris en charge par node, vous pouvez brancher un des nombreux compilateurs qui compilent une version future de JavaScript à une version actuelle. Exemple : voir l'exemple [examples/typescript](https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16) ou le [tutoriel webpack](Webpack.md).

Voici quelques exemples de ces compilateurs :

- [Babel](https://babeljs.io/)
- [TypeScript](http://www.typescriptlang.org/)
- [async-to-gen](http://github.com/leebyron/async-to-gen#jest)
- Pour construire votre propre transformateur, veuillez visiter la section [Custom Transformer] (TutorialReact.md#custom-transformers)

Vous pouvez passer la configuration à un transformateur comme `{filePattern : ['path-to-transformer', {options}]}` Par exemple, pour configurer le babel-jest pour un comportement non par défaut, `{"\\.js$": ['babel-jest', {rootMode: "upward"}]}`

_Note : un transformateur ne fonctionne qu'une fois par fichier, sauf si le fichier a changé. Pendant le développement d'un transformateur, il peut être utile d'exécuter Jest avec "-pas de cache" afin d'effacer fréquemment le cache de Jest (Troubleshooting.md#caching-issues)._

_Note : lors de l'ajout de transformateurs de code supplémentaires, cela écrasera la configuration par défaut et `babel-jest` ne sera plus chargé automatiquement. Si vous voulez l'utiliser pour compiler du JavaScript ou du Typescript, il faut le définir explicitement en ajoutant `{"^.+\\\\.[jt]sx?$" : "babel-jest"}` à la propriété "transform". Voir le [plugin babel-jest](https://github.com/facebook/jest/tree/master/packages/babel-jest#setup)_

### `transformIgnorePatterns` [array\<string>]

Un tableau de chaînes de motifs regexp qui sont comparées à tous les chemins d'accès des fichiers sources avant la transformation. Si le chemin de test correspond à l'un des motifs, il ne sera pas transformé.

Ces chaînes de motifs sont comparées au chemin complet. Utilisez le token `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents.

Exemple : `["<répertoire racine>/bower_components/", "<répertoire racine>/node_modules/"]`.

Il arrive parfois (en particulier dans les projets React Native ou TypeScript) que des modules tiers soient publiés comme non transposés. Comme tous les fichiers à l'intérieur de `node_modules` ne sont pas transformés par défaut, Jest ne comprendra pas le code de ces modules, ce qui entraînera des erreurs de syntaxe. Pour surmonter cela, vous pouvez utiliser `transformIgnorePatterns` pour permettre la transposition de ces modules. Vous trouverez un bon exemple de ce cas d'utilisation dans [React Native Guide] (https://jestjs.io/docs/en/tutorial-react-native#transformignorepatterns-customization).

### `unmockedModulePathPatterns` [array\<string>]

Par défaut : `[]`

Un tableau de l'ensemble de chaînes de regexp qui sont comparées à tous les modules avant que le chargeur de modules ne renvoie automatiquement une maquette. Si le chemin d'un module correspond à l'un des modèles de cette liste, il ne sera pas automatiquement simulé par le chargeur de module.

Cette fonction est utile pour certains modules "utilitaires" couramment utilisés qui servent presque toujours de détails de mise en œuvre (comme les traits de soulignement, les tirets, etc.). Il est généralement préférable de réduire cette liste au minimum et de toujours utiliser des appels explicites à la fonction `jest.mock()`/`jest.unmock()` dans les tests individuels. Il est beaucoup plus facile pour les autres lecteurs du test de raisonner sur l'environnement dans lequel le test sera exécuté.

Il est possible d'outrepasser cette configuration dans les tests individuels en appelant explicitement `jest.mock()` en haut du fichier de test.

### `verbose` [boolean]

Par défaut : `false`

Indique si chaque test individuel doit être signalé pendant l'exécution. Toutes les erreurs seront également indiquées en bas après l'exécution. Notez que si un seul fichier de test est exécuté, il sera par défaut `true`.

### `watchPathIgnorePatterns` [array\<string>]

Par défaut : `[]`

Un tableau de l'ensemble de chaînes de regexp qui sont comparés à tous les chemins d'accès des fichiers sources avant de relancer les tests en mode veille. Si le chemin de fichier correspond à l'un des modèles, il ne déclenchera pas de nouveaux tests lors de la mise à jour.

Ces modèles sont comparés au chemin d'accès complet. Utilisez le jeton de chaîne `<rootDir>` pour inclure le chemin d'accès au répertoire racine de votre projet afin d'éviter qu'il ignore accidentellement tous vos fichiers dans des environnements différents qui peuvent avoir des répertoires racine différents. Exemple : `["<répertoire racine>/node_modules/"]`.

Même si rien n'est spécifié ici, l'observateur ignorera les modifications de tous les fichiers et répertoires cachés, c'est-à-dire les fichiers et les dossiers qui commencent par un point (`.`).

### `watchPlugins` [array\<string | [string, Object]>]

Par défaut : `[]`

Cette option vous permet d'utiliser des plugins de surveillance personnalisés. En savoir plus sur les plugins de surveillance [ici] (watch-plugins).

Voici quelques exemples de plugins watch :

- [`jest-watch-master`](https://github.com/rickhanlonii/jest-watch-master)
- [`jest-watch-select-projects`](https://github.com/rogeliog/jest-watch-select-projects)
- [`jest-watch-suspend`](https://github.com/unional/jest-watch-suspend)
- [`jest-watch-typeahead`](https://github.com/jest-community/jest-watch-typeahead)
- [`jest-watch-yarn-workspaces`](https://github.com/cameronhunter/jest-watch-directories/tree/master/packages/jest-watch-yarn-workspaces)

_Note : Les valeurs de la propriété `watchPlugins` peuvent omettre le préfixe `jest-watch-` du nom du paquet.

### `//` [string]

No default

Cette option permet de faire des commentaires dans `package.json`. Incluez le texte du commentaire comme valeur de cette clé n'importe où dans `package.json`.

Exemple:

```json
{
  "name": "my-project",
  "jest": {
    "//": "Comment goes here",
    "verbose": true
  }
}
```


# Les options CLI de Jest

Le programme d'exécution de la ligne de commande `jest` dispose d'un certain nombre d'options utiles. Vous pouvez lancer `jest --help` pour voir toutes les options disponibles. La plupart des options présentées ci-dessous peuvent également être utilisées ensemble pour effectuer des tests exactement comme vous le souhaitez. Chacune des options de Jest [Configuration](Configuration.md) peut également être spécifiée par le CLI.

En voici un bref aperçu :

## En ligne de commande

Effectue tous les tests (par défaut):

```bash
jest
```

Effectue seulement les tests qui ont été spécifiez avec un modèle ou un nom de fichier :

```bash
jest my-test #or
jest path/to/my-test.js
```

Effectue des tests relatifs aux fichiers modifiés sur la base hg/git (fichier non engagés):

```bash
jest -o
```

Effectue les tests relatifs à `chemin/vers/fichierA.js` et `chemin/vers/fichierB.js` :

```bash
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
```

Effectue les tests qui correspondent à ce nom de spécification (correspondance avec le nom dans `describe` ou `test`, basiquement).

```bash
jest -t name-of-spec
```

Run watch mode:

```bash
jest --watch #runs jest -o by default
jest --watchAll #runs all tests
```

Le mode veille permet aussi de spécifier le nom ou le chemin d'accès à un fichier pour se concentrer sur un ensemble spécifique de tests.

## Utilisation de yarn

Si vous exécutez Jest via `yarn test`, vous pouvez passer les arguments de la ligne de commande directement en tant qu'arguments Jest.

Au lieu de :

```bash
jest -u -t="ColorPicker"
```

Vous pouvez utiliser :

```bash
yarn test -u -t="ColorPicker"
```

## Utilisation des scripts npm

Si vous exécutez Jest via `npm test`, vous pouvez toujours utiliser les arguments de la ligne de commande en insérant un `--` entre `npm test` et les arguments de Jest.

Au lieu de :

```bash
jest -u -t="ColorPicker"
```

Vous pouvez utiliser :

```bash
npm test -- -u -t="ColorPicker"
```

## Le support des arguments Camelcase & dashed

Jest prend en charge les formats des arguments en camelcase et dashed. Les exemples suivants auront un résultat égal :

```bash
jest --collect-coverage
jest --collectCoverage
```

Les arguments pouvent aussi être mélangés :

```bash
jest --update-snapshot --detectOpenHandles
```

## Les Options

_Note: Les options CLI ont la priorité sur les valeurs de la [Configuration](Configuration.md)._

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Reference

### `jest <regexForTestFiles>`

Quand vous exécutez `jest` avec un arguement, cet argument est traité comme une expression régulière à mettre en correspondance avec les fichiers de votre projet. Il est possible d'exécuter des suites de test en fournissant un modèle. Seuls les fichiers auquels le modèle correspond seront exécutés. Selon votre terminal, vous devez peut-être citer cet argument: `jest "my.*(complex)?pattern"`. Sous Windows, vous devez utiliser `/` comme séparateur de chemin `\` comme `\\`.

### `--bail`

Alias: `-b`. Quittez la suite de test immédiatement après le nombre `n` de suites de tests échouées. La valeur par défaut est `1`.

### `--cache`

L'utilisation de cache est par défaut 'vrai'. Pour désactiver le cache utiliser `--no-cache`. _Note: le cache doit être désactivé que si vous rencontrez des problèmes liés à la mise en cache. En moyenne, la désactiation du cache rend Jest deux fois plus lent._

Si vous voulez inspecter le cache, utiliser `--showConfig` et regarder la valeur de `cacheDirectory`. Si vous devez nettoyer le cache, utilisez `--clearCache`.

### `--changedFilesWithAncestor`

Exécute des tests liés aux changement actuels et aux changements effectués lors du dernier commit. Se comporte de la même manière que `--onlyChanged`.

### `--changedSince`

Exécute des tests liés aux changements depuis la branche fournie. Si la branche actuelle a divergé de la branche donnée, alors seuls les changements effectués localement seront testés. Se comporte de la même manière que `--onlyChanged`.


### `--ci`

Lorsque cette option est proposée, Jest suppose qu'il fonctionne dans un environnement CI. Cela change le comportement lorsqu'un nouvel instantané est rencontré. Au lieu de stocker automatiquement un nouvel instantané, le test échouera et Jest devra être exécuté avec `--updateSnapshot`.


### `--clearCache`

Supprime le répertoire de cache de Jest et quitte ensuite sans effectuer de tests. Supprime le `cacheDirectory` si l'option est passée, ou le répertoire de cache par défaut de Jest. Le répertoire de cache par défaut peut être trouvé en appelant `jest --showConfig`. _Note : la suppression du cache réduira les performances_.

### `--collectCoverageFrom=<glob>`

Un modèle de globalité relatif à `rootDir` correspondant aux fichiers dans lesquels les informations de couverture doivent être collectées.

### `--colors`

Les résultats des tests des forces sont mis en évidence même si la sortie standard n'est pas un ATS.

### `--config=<path>`

Alias : `-c`. Le chemin vers un fichier de configuration Jest spécifiant comment trouver et exécuter des tests. Si aucun `rootDir` n'est défini dans le fichier de configuration, le répertoire contenant le fichier de configuration est supposé être le `rootDir` du projet. Il peut également s'agir d'une valeur codée en JSON que Jest utilisera comme configuration.

### `--coverage[=<boolean>]`

Alias : `--collectCoverage`. Indique que les informations sur la couverture des tests doivent être collectées et rapportées dans la sortie. Passez optionnellement `<boolean>` pour remplacer l'option définie dans la configuration.
### `--coverageProvider=<provider>`

Indique quel fournisseur doit être utilisé pour instrumenter le code pour la couverture. Les valeurs autorisées sont `babel` (par défaut) ou "v8".

Notez que l'utilisation de `v8` est considérée comme expérimentale. Il utilise la couverture du code intégré de V8 plutôt qu'un code basé sur Babel. Il n'est pas aussi bien testé, et il a également été amélioré dans les dernières versions de Node. L'utilisation des dernières versions de Node (v14 au moment où nous écrivons ces lignes) donnera de meilleurs résultats.

### `--debug`

Imprimez les informations de débogage de votre configuration Jest.

### `--detectOpenHandles`

Tentative de collecte et d'impression de poignées ouvertes empêchant la sortie propre de Jest. Utilisez ceci dans les cas où vous devez utiliser "--forceExit" pour que Jest puisse sortir afin de retrouver la raison éventuelle. Cela implique `--runInBand`, ce qui permet de faire des tests en série. Implémenté en utilisant [`async_hooks`](https://nodejs.org/api/async_hooks.html). Cette option a une pénalité de performance significative et ne devrait être utilisée que pour le débogage.

### `--env=<environment>`

L'environnement de test utilisé pour tous les tests. Il peut pointer vers n'importe quel fichier ou module de nœud. Exemples : jsdom", "node" ou "path/to/myenvironment.js".

### `--errorOnDeprecated`

Faites e sorte que les API obsolètes envoient des messages d'erreur utiles. Utile pour faciliter le processus de mise à niveau.

### `--expand`

Alias: `-e`. Utilisez ce drapeau pour afficher les différences et erreurs complètes au lieu d'un patch.

### `--findRelatedTests <spaceSeparatedListOfSourceFiles>`

Trouvez et exécutez les tests qui couvrent une liste de fichiers sources séparés par des espaces et qui ont été passés en argument. Utile pour l'intégration  du hook pré-commit pour exécuter le minimum de tests nécessaires. Peut être utilisé avec `--coverage` pour inclure une couverture de test pour les fichiers sources, pas de duplication des arguments `--collectCoverageFrom` nécessaire.

### `--forceExit`

Forcer Jest à sortir après que tous les tests aient été effectués. Ceci est utile lorsque les ressources mises en place par le code de test ne peuvent pas être nettoyées de manière adéquate. _Note : Cette fonction est une trappe d'échappement. Si Jest ne se termine pas à la fin d'un test, cela signifie que les ressources externes sont toujours maintenues ou que des temporisateurs sont toujours en attente dans votre code. Il est conseillé de démonter les ressources externes après chaque test pour s'assurer que Jest peut s'éteindre proprement. Vous pouvez utiliser `--detectOpenHandles` pour vous aider à le retrouver_.

### `--help`

Afficher les informations d'aide, similaires à cette page.

### `--init`

Générer un fichier de configuration de base. En fonction de votre projet, Jest vous posera quelques questions qui vous aideront à générer un fichier `jest.config.js` avec une courte description pour chaque option.

### `--json`

Prints the test results in JSON. This mode will send all other test output and user messages to stderr.

### `--outputFile=<filename>`

Ecrire les résultats des tests dans un fichier lorsque l'option `--json` est également spécifiée. La structure JSON renvoyée est documentée dans [testResultsProcessor](Configuration.md#testresultsprocessor-string).

### `--lastCommit`

Exécutez tous les tests affectés par les changements de fichiers dans le dernier commit effectué. Se comporte de manière similaire à `--onlyChanged`.

### `--listTests`

Liste tous les tests en tant que JSON que Jest va exécuter compte tenu des arguments, et sort. Ceci peut être utilisé avec `--findRelatedTests` pour savoir quels tests Jest va exécuter.

### `--logHeapUsage`

Enregistre l'utilisation du tas après chaque test. Utile pour déboguer les fuites de mémoire. S'utilise avec `--runInBand` et `--expose-gc` dans le noeud.

### `--maxConcurrency=<num>`

Empêche Jest d'exécuter simultanément plus de tests que la quantité spécifiée. N'affecte que les tests qui utilisent `test.concurrent`.

### `--maxWorkers=<num>|<string>`

Alias : `w`. Spécifie le nombre maximum de travailleurs que le groupe de travailleurs va engendrer pour effectuer des tests. En mode d'exécution unique, le nombre de noyaux disponibles sur votre machine moins un pour le fil principal est utilisé par défaut. En mode veille, le nombre par défaut est de la moitié des noyaux disponibles sur votre machine pour garantir que Jest est discret et ne broie pas votre machine à l'arrêt. Il peut être utile d'ajuster cette valeur dans les environnements à ressources limitées comme les CI, mais les valeurs par défaut devraient être adéquates pour la plupart des cas d'utilisation.

Pour les environnements disposant d'unités centrales variables, vous pouvez utiliser une configuration basée sur le pourcentage : `--maxWorkers=50%`.

### `--noStackTrace`

Désactive la trace de la pile dans la sortie des résultats des tests.

### `--notify`

Active les notifications des résultats des tests. Bon pour quand vous ne voulez pas que votre conscience puisse se concentrer sur autre chose que les tests JavaScript.

### `--onlyChanged`

Alias : `-o`. Tentatives d'identification des tests à exécuter en fonction des fichiers qui ont été modifiés dans le dépôt actuel. Ne fonctionne que si vous exécutez des tests dans un dépôt git/hg en ce moment et nécessite un graphe de dépendance statique (c'est-à-dire qu'aucune dynamique n'est nécessaire).

### `--passWithNoTests`

Permet à la suite de test de réussir lorsqu'aucun fichier n'est trouvé.

### `--projects <path1> ... <pathN>`

Effectuer des tests à partir d'un ou plusieurs projets, trouvés dans les chemins spécifiés ; prend également des chemins globaux. Cette option est l'équivalent CLI de l'option de configuration [`projects`](configuration#projects-arraystring--projectconfig). Notez que si les fichiers de configuration sont trouvés dans les chemins spécifiés, _tous_ les projets spécifiés dans ces fichiers de configuration seront exécutés.

### `--reporters`

Effectuez des tests avec des rapporteurs spécifiques. Les [options des rapporteurs](configuration#reporters-arraymodulename--modulename-options) ne sont pas disponibles via le CLI. Exemple avec plusieurs rapporteurs :

`jest --reporters="default" --reporters="jest-junit"`

### `--runInBand`

Alias : "-i". Effectuer tous les tests en série dans le processus en cours, plutôt que de créer un groupe de processus enfants qui effectuent des tests. Cela peut être utile pour le débogage.

### `--selectProjects <project1> ... <projectN>`

N'effectuez que les tests des projets spécifiés. Jest utilise l'attribut `displayName` dans la configuration pour identifier chaque projet. Si vous utilisez cette option, vous devez fournir un `displayName` à tous vos projets.

### `--runTestsByPath`

N'effectuez que les tests qui ont été spécifiés avec leurs trajectoires exactes.

_Note : La correspondance de regex par défaut fonctionne bien sur de petites séries, mais devient lente si elle est fournie avec des modèles multiples et/ou contre un grand nombre de tests. Cette option remplace la logique de correspondance de regex et optimise ainsi le temps que Jest prend pour filtrer des fichiers de test spécifiques_

### `--setupTestFrameworkScriptFile=<file>`

Le chemin vers un module qui exécute un certain code pour configurer ou mettre en place le cadre de test avant chaque test. Attention, les fichiers importés par le script de configuration ne seront pas simulés pendant les tests.

### `--showConfig`

Imprimez votre configuration Jest, puis quittez.

### `--silent`

Empêcher les tests d'imprimer des messages via la console.

### `--testNamePattern=<regex>`

Alias : `-t`. N'effectuez que des tests avec un nom qui correspond à la regex. Par exemple, supposons que vous ne vouliez exécuter que des tests liés à l'autorisation qui auront des noms comme `"GET /api/posts with auth"`, alors vous pouvez utiliser `jest -t=auth`.

Note : La regex est comparée au nom complet, qui est une combinaison du nom du test et de tous les blocs de description qui l'entourent.

### `--testLocationInResults`

Ajout d'un champ `localisation` pour les résultats des tests. Utile si vous voulez signaler le lieu d'un test dans un rapport.

Notez que la `column` est indexée à 0 alors que la `line` ne l'est pas.

```json
{
  "column": 4,
  "line": 5
}
```

### `--testPathPattern=<regex>`

Une chaîne de motifs regexp qui est comparée à tous les chemins de test avant d'exécuter le test. Sous Windows, vous devrez utiliser `/` comme séparateur de chemin ou échapper `\` comme `\\`.

### `--testPathIgnorePatterns=[array]`

Un ensemble de chaînes de motifs regexp qui sont testées par rapport à tous les chemins de test avant d'être exécutées. Contrairement à `--testPathPattern`, il n'exécutera ces tests qu'avec un chemin qui ne correspond pas aux expressions regexp fournies.

### `--testRunner=<path>`

Vous permettez  de spécifier un testeur personnalisé.

### `--testSequencer=<path>`

Permet de spécifier un séquenceur de test personnalisé. Veuillez vous référer à la documentation de la propriété de configuration correspondante pour plus de détails.

### `--testTimeout=<number>`

Délai d'attente par défaut d'un test en millisecondes. Valeur par défaut : 5000.

### `--updateSnapshot`

Alias : `-u`. Utilisez ce drapeau pour réenregistrer chaque instantané qui échoue pendant ce test. Peut être utilisé avec un modèle de suite de tests ou avec `--testNamePattern` pour réenregistrer les instantanés.

### `--useStderr`

Déviez toutes les sorties vers stderr (standard error).

### `--verbose`

Afficher les résultats des tests individuels avec la hiérarchie des suites de tests.

### `--version`

Alias : "v". Imprimez la version et quittez.

### `--watch`

Surveillez les fichiers pour les modifications et refaites les tests liés aux fichiers modifiés. Si vous voulez relancer tous les tests lorsqu'un fichier a été modifié, utilisez plutôt l'option `--watchAll`.

### `--watchAll`

Surveillez les fichiers pour détecter les changements et refaites tous les tests lorsque quelque chose change. Si vous voulez relancer uniquement les tests qui dépendent des fichiers modifiés, utilisez l'option `--watch`.

Utilisez `--watchAll=false` pour désactiver explicitement le mode de surveillance. Notez que dans la plupart des environnements de CI, ceci est automatiquement géré pour vous.

### `--watchman`

S'il faut utiliser le gardien pour le triage des dossiers. Par défaut, c'est vrai. Désactiver l'utilisation de `--no-watchman`.
