---
id: api
title: Globals
---

# Les api générales

Dans vos fichiers de test, Jest place chacune de ces méthodes et chacun de ces objets dans l'environnement global. Vous n'avez pas besoin d'exiger ou d'importer quoi que ce soit pour les utiliser. Cependant, si vous préférez des importations explicites, vous pouvez faire `import {describe, expect, test} depuis '@jest/globals'`.

## Methods

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Reference

### `afterAll(fn, timeout)`

Exécute une fonction après que tous les tests de ce fichier ont été effectués. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de continuer.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. Note : Le délai par défaut est de 5 secondes.

Ceci est souvent utile si vous voulez nettoyer un état de configuration global partagé entre les tests.

Par exemple :

```js
const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterAll(() => {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```


Ici, l'`afterAll` garantit que la `cleanUpDatabase` est appelée après tous les tests effectués.

Si `afterAll` est à l'intérieur d'un bloc `describe`, il s'exécute à la fin du bloc describe.

Si vous voulez effectuer un nettoyage après chaque test au lieu de tous les tests, utilisez `afterEach` à la place.

### `afterEach(fn, timeout)`

Exécute une fonction après la fin de chacun des tests de ce dossier. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de continuer.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez nettoyer un état temporaire créé par chaque test.

Par exemple:

```js
const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterEach(() => {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```

Ici, le `afterEach` assure que la `cleanUpDatabase` est appelée après chaque test.

Si `afterEach` est à l'intérieur d'un bloc `describe`, il ne s'exécute qu'après les tests qui sont à l'intérieur de ce bloc de description.

Si vous voulez faire un nettoyage une seule fois, après tous les tests effectués, utilisez plutôt `afterAll`.

### `beforeAll(fn, timeout)`


Exécute une fonction avant que l'un des tests de ce fichier ne soit exécuté. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant d'exécuter les tests.

En option, vous pouvez fournir un `timeout` (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez mettre en place un état global qui sera utilisé par de nombreux tests.

Par exemples :

```js
const globalDatabase = makeGlobalDatabase();

beforeAll(() => {
  // Efface la base de données et ajoute quelques données de test.
  // Jest attendra que cette promesse se concrétise avant de lancer les tests.
  return globalDatabase.clear().then(() => {
    return globalDatabase.insert({testData: 'foo'});
  });
});

// Comme nous n'avons mis en place la base de données qu'une seule fois dans cet exemple, il est important
// que nos tests ne le modifient pas.
test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});
```

Ici, le `beforeAll` garantit que la base de données est mise en place avant que les tests ne soient effectués. Si la configuration était synchrone, vous pourriez le faire sans `beforeAll`. La clé est que Jest attendra une promesse de résolution, donc vous pouvez aussi avoir une configuration asynchrone.

Si `beforeAll` est à l'intérieur d'un bloc `describe`, il s'exécute au début du bloc describe.

Si vous voulez lancer quelque chose avant chaque test au lieu de lancer un test, utilisez plutôt `beforeEach`.

### `beforeEach(fn, timeout)`

Exécute une fonction avant l'exécution de chacun des tests de ce fichier. Si la fonction renvoie une promesse ou est un générateur, Jest attend que cette promesse soit résolue avant de lancer le test.

En option, vous pouvez fournir un ``timeout`` (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

Ceci est souvent utile si vous voulez réinitialiser un état global qui sera utilisé par de nombreux tests.

Par exemple :

```js
const globalDatabase = makeGlobalDatabase();

beforeEach(() => {
  // Efface la base de données et ajoute quelques données de test.
  // Jest attendra que cette promesse se concrétise avant de lancer les tests.
  return globalDatabase.clear().then(() => {
    return globalDatabase.insert({testData: 'foo'});
  });
});

test('can find things', () => {
  return globalDatabase.find('thing', {}, results => {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () => {
  return globalDatabase.insert('thing', makeThing(), response => {
    expect(response.success).toBeTruthy();
  });
});
```

Ici, le `beforeEach` garantit que la base de données est réinitialisée pour chaque test.

Si `beforeEach` est à l'intérieur d'un bloc `describe`, il s'exécute pour chaque test dans le bloc describe.

Si vous n'avez besoin d'exécuter un code de configuration qu'une seule fois, avant tout test, utilisez plutôt `beforeAll`.

### `describe(name, fn)`

`describe(name, fn)` crée un bloc qui regroupe plusieurs tests connexes. Par exemple, si vous avez un objet "ma boisson" qui est censé être délicieux mais pas aigre, vous pouvez le tester avec :

```js
const myBeverage = {
  delicious: true,
  sour: false,
};

describe('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});
```

Ce n'est pas obligatoire - vous pouvez écrire les blocs `test` directement au niveau supérieur. Mais cela peut être pratique si vous préférez que vos tests soient organisés en groupes.

Vous pouvez également imbriquer les blocs ``describe`` si vous disposez d'une hiérarchie de tests :

```js
const binaryStringToNumber = binString => {
  if (!/^[01]+$/.test(binString)) {
    throw new CustomError('Not a binary number.');
  }

  return parseInt(binString, 2);
};

describe('binaryStringToNumber', () => {
  describe('given an invalid binary string', () => {
    test('composed of non-numbers throws CustomError', () => {
      expect(() => binaryStringToNumber('abc')).toThrowError(CustomError);
    });

    test('with extra whitespace throws CustomError', () => {
      expect(() => binaryStringToNumber('  100')).toThrowError(CustomError);
    });
  });

  describe('given a valid binary string', () => {
    test('returns the correct number', () => {
      expect(binaryStringToNumber('100')).toBe(4);
    });
  });
});
```

### `describe.each(table)(name, fn, timeout)`

Utilisez `describe.each` si vous continuez à dupliquer les mêmes suites de tests avec des données différentes. Le fichier `describe.each` vous permet d'écrire la suite de tests une fois et de transmettre les données.

`describe.each` est disponible avec deux API :

#### 1. `describe.each(table)(name, fn, timeout)`

- `table`: `Array` de tableaux avec les arguments qui sont passés dans le `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau 1D de primitives, il sera mappé en interne à un tableau , c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`
- `name`: `String` le titre de la suite de tests.
  - Générer des titres de test uniques en injectant des paramètres de positionnement avec le formatage [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Floating point value.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index of the test case.
    - `%%` - signe de pourcentage unique ('%'). Ceci ne consomme pas d'argument
- `fn`: `Function` la suite de tests à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de fonction.
- En option, vous pouvez fournir un `timeout` (en milliseconds) pour spécifier combien de temps il faut attendre pour chaque ligne avant d'abandonner. _Note : le délai par défaut est de 5 secondes_.

Exemple:

```js
describe.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () => {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () => {
    expect(a + b).not.toBeLessThan(expected);
  });
});
```

#### 2. `` describe.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
  - Première ligne des en-têtes de colonne des noms de variables, séparés par des " | ".
  - Une ou plusieurs lignes de données ultérieures fournies sous forme d'expressions littérales modèles utilisant la syntaxe `${valeur}`.
- `name`: `String` du titre de la suite de tests, utilisez `$variable` pour injecter des données de test dans le titre de la suite à partir des expressions de modèle balisées.
  - Pour injecter des valeurs d'objets imbriquées, vous pouvez fournir un keyPath, c'est-à-dire `$variable.path.to.value`.
- `fn` : `Fonction` la suite de tests à exécuter, c'est la fonction qui recevra l'objet de données de test.
- En option, vous pouvez fournir un `timeout` (en millisecondes) pour spécifier combien de temps il faut attendre pour chaque ligne avant d'abandonner. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
describe.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('$a + $b', ({a, b, expected}) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () => {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () => {
    expect(a + b).not.toBeLessThan(expected);
  });
});
```

### `describe.only(name, fn)`

Également sous l'alias: `fdescribe(name, fn)`

Vous pouvez utiliser `describe.only` si vous ne voulez exécuter qu'un seul bloc de description :

```js
describe.only('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe('my other beverage', () => {
  // ... seront ignorées
});
```

### `describe.only.each(table)(name, fn)`

Également sous l'alias: `fdescribe.each(table)(name, fn)` and `` fdescribe.each`table`(name, fn) ``

Utilisez `describe.only.each` si vous voulez seulement exécuter des suites de tests spécifiques de tests pilotés par les données.

Le programme `describe.only.each` est disponible avec deux API :

#### `describe.only.each(table)(name, fn)`

```js
describe.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` describe.only.each`table`(name, fn) ``

```js
describe.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  test('passes', () => {
    expect(a + b).toBe(expected);
  });
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `describe.skip(name, fn)`

Également sous l'alias: `xdescribe(name, fn)`

Vous pouvez utiliser `describe.skip` si vous ne voulez pas exécuter un bloc de description particulier :

```js
describe('my beverage', () => {
  test('is delicious', () => {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () => {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe.skip('my other beverage', () => {
  // ... seront ignorées
});
```

L'utilisation de `describe.skip` est souvent une alternative plus propre que de commenter temporairement une partie des tests.

### `describe.skip.each(table)(name, fn)`

Also under the aliases: `xdescribe.each(table)(name, fn)` et `` xdescribe.each`table`(name, fn) ``

Utilisez `describe.skip.each` si vous voulez arrêter d'exécuter une suite de tests basés sur des données.

`describe.skip.each` est disponible avec deux API :

#### `describe.skip.each(table)(name, fn)`

```js
describe.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected); // ne sera pas gérée
  });
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` describe.skip.each`table`(name, fn) ``

```js
describe.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  test('will not be ran', () => {
    expect(a + b).toBe(expected); // ne sera pas gérée
  });
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test(name, fn, timeout)`

Également sous l'alias: `it(name, fn, timeout)`

Tout ce dont vous avez besoin dans un fichier de test est la méthode `test` qui exécute un test. Par exemple, disons qu'il y a une fonction `inchesOfRain()` qui devrait être à zéro. Tout votre test pourrait l'être :

```js
test('did not rain', () => {
  expect(inchesOfRain()).toBe(0);
});
```

Le premier argument est le nom du test ; le deuxième argument est une fonction qui contient les attentes à tester. Le troisième argument (facultatif) est le "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. _Note : Le délai par défaut est de 5 secondes_.

> Note : Si une **promesse est retournée** de `test`, Jest attendra la résolution de la promesse avant de laisser le test se terminer. Jest attendra également si vous **fournissez un argument à la fonction de test**, généralement appelé "done". Cela peut être pratique lorsque vous voulez tester les rappels. Voir comment tester le code async [ici](TestingAsyncCode.md#callbacks).

Par exemple, disons que `fetchBeverageList()` renvoie une promesse qui est supposée se résoudre à une liste qui contient du `citron`. Vous pouvez tester cela avec :

```js
test('has lemon in it', () => {
  return fetchBeverageList().then(list => {
    expect(list).toContain('lemon');
  });
});
```

Même si l'appel au `test` revient tout de suite, le test n'est pas terminé tant que la promesse n'est pas résolue.

### `test.concurrent(name, fn, timeout)`

Également sous l'alias: `it.concurrent(name, fn, timeout)`

Utilisez `test.concurrent` si vous voulez que le test s'exécute en même temps.

> Note : `test.concurrent` est considéré comme expérimental - voir [ici])https://github.com/facebook/jest/labels/Area%3A%20Concurrent) pour plus de détails sur les fonctionnalités manquantes et autres problèmes

Le premier argument est le nom du test ; le second argument est une fonction asynchrone qui contient les attentes à tester. Le troisième argument (facultatif) est le "délai d'attente" (en millisecondes) pour spécifier le temps d'attente avant l'abandon. Note : Le délai par défaut est de 5 secondes.

```
test.concurrent('addition of 2 numbers', async () => {
  expect(5 + 3).toBe(8);
});

test.concurrent('subtraction 2 numbers', async () => {
  expect(5 - 3).toBe(2);
});
```

> Note : Utilisez `maxConcurrency` dans la configuration pour empêcher Jest d'exécuter plus que la quantité spécifiée de tests en même temps

### `test.concurrent.each(table)(name, fn, timeout)`

Également sous l'alias: `it.concurrent.each(table)(name, fn, timeout)`

Utilisez `test.concurrent.each` si vous continuez à dupliquer le même test avec des données différentes. `test.each` vous permet d'écrire le test une fois et de passer les données, les tests sont tous exécutés de manière asynchrone.

`test.concurrent.each` est disponible avec deux API :

#### 1. `test.concurrent.each(table)(name, fn, timeout)`

- `table`: Un `Array` de tableaux avec les arguments qui sont passés dans le test `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau de 1D de primitives, il sera mis en correspondance avec un tableau interne, c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`;
- `name`: `String` le titre bloc du test.
  -   - Générer des titres de test uniques en injectant des paramètres de positionnement avec [ le formatage `printf`](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Valeur en virgule flottante.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index du cas type.
    - `%%` - le signe de pourcentage unique ("%"). Cela ne consomme pas d'argument.
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de la fonction, **cela devra être une fonction asynchrone**.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.
Example:

```js
test.concurrent.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### 2. `` test.concurrent.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
  - La première ligne des en-têtes de colonne du nom de la variable, spéraré avec un `|`.
  - Une ou plusieurs lignes ultérieures de données fournies comme modèles d'expressions littérales en utilisant la syntaxe `${valeur}`.
- `name`: En utilisant `String` comme titre du test , utilisez `$variable` pour injecter des données de test dans le titre à partir des expressions de modèle balisées
  - Pour injecter des valeurs d'objets imbriqués, vous pouvez fournir un keyPath, c'est-à-dire `$variable.path.to.value`
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra l'objet de données de test, **cela devra être une fonction asynchrone**.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.concurrent.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

### `test.concurrent.only.each(table)(name, fn)`

Également sous l'alias: `it.concurrent.only.each(table)(name, fn)`

Utilisez `test.concurrent.only.each` si vous voulez seulement exécuter des tests spécifiques avec des données de test différentes en même temps.

`test.concurrent.only.each` est disponible avec deux API:

#### `test.concurrent.only.each(table)(name, fn)`

```js
test.concurrent.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', async (a, b, expected) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.only.each`table`(name, fn) ``

```js
test.concurrent.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', async ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.concurrent.skip.each(table)(name, fn)`

Également sous l'alias: `it.concurrent.skip.each(table)(name, fn)`

Utilisez `test.concurrent.skip.each` si vous voulez arrêter d'exécuter une collection de tests asynchrones basés sur des données.

`test.concurrent.skip.each` est disponible avec deux APIs:

#### `test.concurrent.skip.each(table)(name, fn)`

```js
test.concurrent.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', async (a, b, expected) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.concurrent.skip.each`table`(name, fn) ``

```js
test.concurrent.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', async ({a, b, expected}) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.each(table)(name, fn, timeout)`

Également sous l'alias: `it.each(table)(name, fn)` et `` it.each`table`(name, fn) ``

Utilisez `test.each` si vous continuez à dupliquer le même test avec des données différentes. Le `test.each` vous permet d'écrire le test une fois et de transmettre les données.

`test.each` est disponible avec deux APIs:

#### 1. `test.each(table)(name, fn, timeout)`

- `table`: Un `Array` de tableaux avec les arguments qui sont passés dans le test `fn` pour chaque ligne.
  - _Note_ Si vous passez un tableau de 1D de primitives, il sera mis en correspondance avec un tableau interne, c'est-à-dire `[1, 2, 3] -> [[1], [2], [3]]`;
- `name`: `String` le titre bloc du test.
  - Générer des titres de test uniques en injectant des paramètres de positionnement avec [ le formatage `printf`](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Valeur en virgule flottante.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index du cas type.
    - `%%` - le signe de pourcentage unique ("%"). Cela ne consomme pas d'argument.
- `fn`: `Function` le test à exécuter, c'est la fonction qui recevra les paramètres de chaque ligne comme arguments de la fonction.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### 2. `` test.each`table`(name, fn, timeout) ``

- `table`: `Tagged Template Literal`
- Première ligne des en-têtes de colonne des noms de variables, séparés par des " | ".
- Une ou plusieurs lignes de données ultérieures fournies sous forme d'expressions littérales modèles utilisant la syntaxe `${valeur}`.
- `name`: `String` le titre du test, utilisez `$variable`pour injecter des données de test dans le titre du test à partir des expressions de modèle balisées
- Pour injecter des valeurs d'objet imbriquées, vous pouvez fournir un keyPath, c'est-à-dire . `$variable.path.to.value`
- `fn`: `Function` le test à effectuer, c'est la fonction qui recevra l'objet de données de test.
- En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier le temps d'attente pour chaque ligne avant l'interruption. _Note : Le délai par défaut est de 5 secondes_.

Exemple:

```js
test.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

### `test.only(name, fn, timeout)`

Également sous l'alias: `it.only(name, fn, timeout)`, et `fit(name, fn, timeout)`

Lorsque vous déboguez un gros fichier de test, vous ne voudrez souvent exécuter qu'un sous-ensemble de tests. Vous pouvez utiliser `.only` pour spécifier quels sont les seuls tests que vous voulez exécuter dans ce fichier de test.

En option, vous pouvez fournir un "délai d'attente" (en millisecondes) pour spécifier combien de temps il faut attendre avant d'abandonner. Note : Le délai par défaut est de 5 secondes.

Par exemple, disons que vous avez fait ces tests :

Traduit avec www.DeepL.com/Translator (version gratuite)

```js
test.only('it is raining', () => {
  expect(inchesOfRain()).toBeGreaterThan(0);
});

test('it is not snowing', () => {
  expect(inchesOfSnow()).toBe(0);
});
```

Seul le test "it is rainignt" sera exécuté dans ce fichier de test, puisqu'il est exécuté avec `test.only`.

Habituellement, vous ne vérifiez pas le code en utilisant `test.only` dans le contrôle des sources - vous l'utilisez pour le débogage, et le supprimez une fois que vous avez corrigé les tests cassés.

### `test.only.each(table)(name, fn)`

Également sous l'alias: `it.only.each(table)(name, fn)`, `fit.each(table)(name, fn)`, `` it.only.each`table`(name, fn) `` et `` fit.each`table`(name, fn) ``

Utilisez `test.only.each` si vous voulez seulement effectuer des tests spécifiques avec des données de test différentes.

`test.only.each` est disponible avec deux APIs:

#### `test.only.each(table)(name, fn)`

```js
test.only.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.only.each`table`(name, fn) ``

```js
test.only.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});

test('will not be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.skip(name, fn)`

Également sous l'alias: `it.skip(name, fn)`, `xit(name, fn)`, et `xtest(name, fn)`

Lorsque vous maintenez une base de données importante, vous pouvez parfois trouver un test qui est temporairement interrompu pour une raison quelconque. Si vous voulez sauter l'exécution de ce test, mais que vous ne voulez pas supprimer ce code, vous pouvez utiliser `test.skip` pour spécifier certains tests à sauter.

Par exemple, disons que vous avez ces tests :

```js
test('it is raining', () => {
  expect(inchesOfRain()).toBeGreaterThan(0);
});

test.skip('it is not snowing', () => {
  expect(inchesOfSnow()).toBe(0);
});
```

Seul le test "it is raining" sera effectué, puisque l'autre test est effectué avec `test.skip`.

Vous pouvez commenter le test, mais il est souvent un peu plus agréable d'utiliser `test.skip` car il maintient l'indentation et la mise en évidence syntaxique.

### `test.skip.each(table)(name, fn)`

Also under the aliases: `it.skip.each(table)(name, fn)`, `xit.each(table)(name, fn)`, `xtest.each(table)(name, fn)`, `` it.skip.each`table`(name, fn) ``, `` xit.each`table`(name, fn) `` and `` xtest.each`table`(name, fn) ``

Utilisez `test.skip.each` si vous voulez arrêter d'effectuer une collecte de données.

`test.skip.each` est disponible avec deux APIs:

#### `test.skip.each(table)(name, fn)`

```js
test.skip.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

#### `` test.skip.each`table`(name, fn) ``

```js
test.skip.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected); // ne sera pas gérée
});

test('will be ran', () => {
  expect(1 / 0).toBe(Infinity);
});
```

### `test.todo(name)`

Également sous l'alias: `it.todo(name)`

Utilisez `test.todo` lorsque vous prévoyez de passer des tests. Ces tests seront mis en évidence dans le résumé à la fin afin que vous sachiez combien de tests il vous reste à faire.

_Note_ : Si vous fournissez une fonction de rappel de test, alors le `test.todo` lancera une erreur. Si vous avez déjà implémenté le test et qu'il est cassé et que vous ne voulez pas qu'il s'exécute, alors utilisez `test.skip` à la place.

Traduit avec www.DeepL.com/Translator (version gratuite)

#### API

- `name`: `String` le titre du plan d'essai.

Exemple:

```js
const add = (a, b) => a + b;

test.todo('add should be associative');
```
